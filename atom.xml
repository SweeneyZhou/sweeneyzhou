<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>格物志</title>
  
  <subtitle>格物致知 知行合一</subtitle>
  <link href="https://sweeneyzhou.top/atom.xml" rel="self"/>
  
  <link href="https://sweeneyzhou.top/"/>
  <updated>2021-04-21T01:31:03.735Z</updated>
  <id>https://sweeneyzhou.top/</id>
  
  <author>
    <name>Sweeney Zhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络编程</title>
    <link href="https://sweeneyzhou.top/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html"/>
    <id>https://sweeneyzhou.top/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html</id>
    <published>2021-04-21T01:01:41.927Z</published>
    <updated>2021-04-21T01:31:03.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一，网络中的三要素"><a href="#一，网络中的三要素" class="headerlink" title="一，网络中的三要素"></a>一，网络中的三要素</h3><h4 id="1-1-ip地址"><a href="#1-1-ip地址" class="headerlink" title="1.1 ip地址"></a>1.1 ip地址</h4><blockquote><p>ip地址用于标识网络中的计算机设备</p><p>查看本机ip地址：cmd -&gt; ipconfig</p><p>ipv4：由32位的二进制数组成，格式：<code>xxx.xxx.xxx.xxx</code>，最多可以标识42亿多个地址</p><p>ipv6：每16个字节为一组，共8组，格式：<code>xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx</code>，每个x是16进制数</p><p>本机的ip地址是：127.0.0.1、localhost</p></blockquote><h4 id="1-2-端口号"><a href="#1-2-端口号" class="headerlink" title="1.2 端口号"></a>1.2 端口号</h4><blockquote><p>端口号用于标识计算机中的应用</p><p>端口号的范围：0~65535</p><p>格式：ip地址:端口号</p></blockquote><h4 id="1-3-传输协议"><a href="#1-3-传输协议" class="headerlink" title="1.3 传输协议"></a>1.3 传输协议</h4><blockquote><p>数据在网络中传输时需要遵循的规则</p><p>在 java.net 包中定义了 UDP、TCP 协议实现数据传输时所需要的类</p></blockquote><h5 id="1-3-1-UDP"><a href="#1-3-1-UDP" class="headerlink" title="1.3.1 UDP"></a>1.3.1 UDP</h5><blockquote><p>UDP：User Datagram Protocol，用户数据报协议</p><p>特点</p><ol><li>不建立连接，发送者不会确认接收者是否存在</li><li>效率高</li><li>不可靠</li><li>应用：在线视频</li><li>代码：在发送数据时，数据必须和目标地址封装在同一个数据包中</li></ol><p>核心类：</p><ol><li>DatagramPacket：数据包，封装了传输的数据，如果是发送者还需要将数据与目标地址都封装在里面</li><li>DatagramSocket：封装了对数据包的发送和接收的类</li></ol></blockquote><h5 id="1-3-2-TCP"><a href="#1-3-2-TCP" class="headerlink" title="1.3.2 TCP"></a>1.3.2 TCP</h5><blockquote><p>TCP：Transfer Control Protocol，传输控制协议</p><p>特点：</p><ol><li>通过三次握手保证建立了连接</li><li>速度慢</li><li>可靠的连接</li><li>应用：聊天、下载、上传</li></ol><p>核心类：</p><ol><li>ServerSocket：服务端</li><li>Socket：客户端</li></ol></blockquote><h3 id="二，InetAddress"><a href="#二，InetAddress" class="headerlink" title="二，InetAddress"></a>二，InetAddress</h3><blockquote><p>InetAddress 类是 java.net 包下的一个用于获取域名、ip地址的类</p><p>静态方法：</p><ol><li>getByName(String host)：host 可以是域名 <a href="http://www.baidu.com,也可以是ip地址/">www.baidu.com，也可以是ip地址</a> 10.11.52.36</li><li>getLocalHost()：获取本机的域名、ip</li><li>getAllByName(String host)：获取指定域名或者ip地址所对应的所有ip地址</li></ol></blockquote><h3 id="三，UDP-通信"><a href="#三，UDP-通信" class="headerlink" title="三，UDP 通信"></a>三，UDP 通信</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收</span></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">7777</span>);</span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">             <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">             DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(b,<span class="number">0</span>,b.length);</span><br><span class="line">             ds.receive(dp);</span><br><span class="line">             <span class="keyword">byte</span>[] data = dp.getData();</span><br><span class="line">             System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发</span></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">             DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">             String msg = <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line">             <span class="keyword">byte</span>[] data = msg.getBytes();</span><br><span class="line">             DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(data,<span class="number">0</span>,data.length, InetAddress.getByName(<span class="string">&quot;10.11.52.36&quot;</span>),<span class="number">6666</span>);</span><br><span class="line">             ds.send(dp);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="四，TCP-通信"><a href="#四，TCP-通信" class="headerlink" title="四，TCP 通信"></a>四，TCP 通信</h3><blockquote><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">1234</span>);</span><br><span class="line"> Socket s = ss.accept();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 收</span></span><br><span class="line"> <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">             <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                 InputStream is = s.getInputStream();</span><br><span class="line">                 <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                 <span class="keyword">int</span> len = is.read(data);</span><br><span class="line">                 System.out.println(<span class="string">&quot;服务器接收到了&quot;</span>+s.getInetAddress().getHostAddress()+<span class="string">&quot;：&quot;</span>+<span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;.start();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 发</span></span><br><span class="line"> <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                 OutputStream os = s.getOutputStream();</span><br><span class="line">                 String msg = <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line">                 os.write(msg.getBytes());</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"> Socket s = <span class="keyword">new</span> Socket(<span class="string">&quot;10.11.52.36&quot;</span>,<span class="number">1234</span>);</span><br><span class="line"> <span class="comment">// 收</span></span><br><span class="line"> <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                 InputStream is = s.getInputStream();</span><br><span class="line">                 <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                 <span class="keyword">int</span> len = is.read(data);</span><br><span class="line">                 System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;.start();</span><br><span class="line"> <span class="comment">// 发</span></span><br><span class="line"> <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                 OutputStream os = s.getOutputStream();</span><br><span class="line">                 String msg = <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line">                 os.write(msg.getBytes());</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-1-聊天室"><a href="#4-1-聊天室" class="headerlink" title="4.1 聊天室"></a>4.1 聊天室</h4><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Socket&gt; sockets;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;服务器开启&quot;</span>);</span><br><span class="line"> sockets = <span class="keyword">new</span> ArrayList&lt;Socket&gt;();</span><br><span class="line"> ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">7890</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">             <span class="keyword">while</span>(count &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">                 Socket s = ss.accept();</span><br><span class="line">                 sockets.add(s);</span><br><span class="line">                 sendAll(s); <span class="comment">// 谁在什么时候进入了聊天室</span></span><br><span class="line">                 <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                     <span class="meta">@Override</span></span><br><span class="line">                     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                         <span class="keyword">try</span>&#123;</span><br><span class="line">                             <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                                 InputStream is = s.getInputStream();</span><br><span class="line">                                 <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                                 <span class="keyword">int</span> len = is.read(data);</span><br><span class="line">                                 String msg = <span class="keyword">new</span> String(data,<span class="number">0</span>,len);</span><br><span class="line">                                 sendAll(s,msg); <span class="comment">// 谁在什么时候说了什么</span></span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;).start();</span><br><span class="line">                 count++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendAll</span><span class="params">(Socket s,String str)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"> String ip = s.getInetAddress().getHostAddress();</span><br><span class="line"> String time = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line"> String msg = time + <span class="string">&quot; &quot;</span> + ip + <span class="string">&quot;：&quot;</span> + str;</span><br><span class="line"> log(msg);</span><br><span class="line"> <span class="keyword">for</span>(Socket socket : sockets)&#123;</span><br><span class="line">     OutputStream os = socket.getOutputStream();</span><br><span class="line">     os.write(msg.getBytes());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendAll</span><span class="params">(Socket s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"> String ip = s.getInetAddress().getHostAddress();</span><br><span class="line"> String time = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line"> String msg = ip + <span class="string">&quot;在&quot;</span> + time + <span class="string">&quot;加入了聊天室&quot;</span>;</span><br><span class="line"> log(msg);</span><br><span class="line"> <span class="keyword">for</span>(Socket socket : sockets)&#123;</span><br><span class="line">     OutputStream os = socket.getOutputStream();</span><br><span class="line">     os.write(msg.getBytes());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"> BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;C:\\Users\\86151\\Desktop\\log.txt&quot;</span>,<span class="keyword">true</span>));</span><br><span class="line"> bw.write(msg);</span><br><span class="line"> bw.newLine();</span><br><span class="line"> bw.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2-文件上传"><a href="#4-2-文件上传" class="headerlink" title="4.2 文件上传"></a>4.2 文件上传</h4><blockquote><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> <span class="comment">// 1.创建本地的文件输入流</span></span><br><span class="line"> FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\mine\\图片\\封面.png&quot;</span>);</span><br><span class="line"> <span class="comment">// 2.创建客户端对象</span></span><br><span class="line"> Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;10.11.52.36&quot;</span>,<span class="number">8888</span>);</span><br><span class="line"> <span class="comment">// 3.创建网络输出流对象</span></span><br><span class="line"> OutputStream os = socket.getOutputStream();</span><br><span class="line"> <span class="comment">// 4.使用本地的文件输入流对象读取图片</span></span><br><span class="line"> <span class="comment">// 5.使用网络输出流对象输出图片</span></span><br><span class="line"> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"> <span class="keyword">int</span> len;</span><br><span class="line"> <span class="keyword">while</span>((len = fis.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">     os.write(data,<span class="number">0</span>,len);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 客户端无法接收服务器的回写数据</span></span><br><span class="line"> <span class="comment">// 原因；本质上是服务器根本没有执行到回写的语句，必须在客户端发送完毕后，告知服务器，发送给服务器一个发送完毕的标记，服务器才能得知接收完毕</span></span><br><span class="line"> socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 6.创建网络输入流对象</span></span><br><span class="line"> InputStream is = socket.getInputStream();</span><br><span class="line"> <span class="keyword">byte</span>[] msg = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line"> <span class="keyword">int</span> length = is.read(msg);</span><br><span class="line"> System.out.println(<span class="keyword">new</span> String(msg,<span class="number">0</span>,length));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> is.close();</span><br><span class="line"> os.close();</span><br><span class="line"> fis.close();</span><br><span class="line"> socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建服务器对象</span></span><br><span class="line">ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">9996</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"> <span class="comment">// 2.接收客户端对象</span></span><br><span class="line"> Socket s = ss.accept();</span><br><span class="line"> <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">             <span class="comment">// 3.创建网络输入流</span></span><br><span class="line">             InputStream is = s.getInputStream();</span><br><span class="line">             <span class="comment">// 指定图片的名字</span></span><br><span class="line">             String filename = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyyMMddHHmmssSS&quot;</span>).format(<span class="keyword">new</span> Date())+<span class="keyword">new</span> Random().nextInt(<span class="number">100000000</span>)+<span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">             <span class="comment">// 5.创建本地文件输出流</span></span><br><span class="line">             FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\86151\\Desktop\\图片\\&quot;</span>+filename);</span><br><span class="line">             <span class="comment">// 6.使用网络输入流读取客户端发来的数据</span></span><br><span class="line">             <span class="comment">// 7.使用本地文件输出流向指定目录中写入数据</span></span><br><span class="line">             <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">             <span class="keyword">int</span> len;</span><br><span class="line">             <span class="keyword">while</span>((len = is.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                 fos.write(data,<span class="number">0</span>,len);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 8.创建网络输出流</span></span><br><span class="line">             OutputStream os = s.getOutputStream();</span><br><span class="line">             os.write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line">             os.close();</span><br><span class="line">             fos.close();</span><br><span class="line">             is.close();</span><br><span class="line">         &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;上传失败&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一，网络中的三要素&quot;&gt;&lt;a href=&quot;#一，网络中的三要素&quot; class=&quot;headerlink&quot; title=&quot;一，网络中的三要素&quot;&gt;&lt;/a&gt;一，网络中的三要素&lt;/h3&gt;&lt;h4 id=&quot;1-1-ip地址&quot;&gt;&lt;a href=&quot;#1-1-ip地址&quot; class=&quot;headerlink&quot; title=&quot;1.1 ip地址&quot;&gt;&lt;/a&gt;1.1 ip地址&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;ip地址用于标识网络中的计算机设备&lt;/p&gt;
&lt;p&gt;查看本机ip地址：cmd -&amp;gt; ipconfig&lt;/p&gt;
&lt;p&gt;ipv4：由32位的二进制数组成，格式：&lt;code&gt;xxx.xxx.xxx.xxx&lt;/code&gt;，最多可以标识42亿多个地址&lt;/p&gt;
&lt;p&gt;ipv6：每16个字节为一组，共8组，格式：&lt;code&gt;xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx&lt;/code&gt;，每个x是16进制数&lt;/p&gt;
&lt;p&gt;本机的ip地址是：127.0.0.1、localhost&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-2-端口号&quot;&gt;&lt;a href=&quot;#1-2-端口号&quot; class=&quot;headerlink&quot; title=&quot;1.2 端口号&quot;&gt;&lt;/a&gt;1.2 端口号&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;端口号用于标识计算机中的应用&lt;/p&gt;
&lt;p&gt;端口号的范围：0~65535&lt;/p&gt;
&lt;p&gt;格式：ip地址:端口号&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="后端编程" scheme="https://sweeneyzhou.top/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JAVA" scheme="https://sweeneyzhou.top/tags/JAVA/"/>
    
    <category term="学习笔记" scheme="https://sweeneyzhou.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础" scheme="https://sweeneyzhou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="ip" scheme="https://sweeneyzhou.top/tags/ip/"/>
    
    <category term="端口号" scheme="https://sweeneyzhou.top/tags/%E7%AB%AF%E5%8F%A3%E5%8F%B7/"/>
    
    <category term="传输协议" scheme="https://sweeneyzhou.top/tags/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="TCP" scheme="https://sweeneyzhou.top/tags/TCP/"/>
    
    <category term="UDP" scheme="https://sweeneyzhou.top/tags/UDP/"/>
    
    <category term="InetAddress" scheme="https://sweeneyzhou.top/tags/InetAddress/"/>
    
    <category term="Socket" scheme="https://sweeneyzhou.top/tags/Socket/"/>
    
    <category term="DatagramSocket" scheme="https://sweeneyzhou.top/tags/DatagramSocket/"/>
    
    <category term="ServerSocket" scheme="https://sweeneyzhou.top/tags/ServerSocket/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="https://sweeneyzhou.top/%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"/>
    <id>https://sweeneyzhou.top/%E5%A4%9A%E7%BA%BF%E7%A8%8B.html</id>
    <published>2021-04-21T01:01:41.902Z</published>
    <updated>2021-04-21T01:28:23.798Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一，概念"><a href="#一，概念" class="headerlink" title="一，概念"></a>一，概念</h3><blockquote><p>进程：正在运行的程序</p><p>线程：是进程中的一个执行单元（一条执行路径），一个进程至少包含一条线程。如果一个进程包含多个线程，这种程序就叫多线程程序</p><p>并发：两件事同时进行</p><p>并行：两件事同时发生</p><p>线程的调度：</p><ol><li>分时调度：所有线程轮流使用CPU，每个线程平均分配CPU的执行权</li><li>抢占式调度：优先让优先级高的线程执行，优先级相同时，CPU随机分配执行权，Java 中多线程的执行方式就是抢占式的</li></ol><p>注：Java 程序在没有额外开启线程的情况下也有两个线程：主函数所在的主线程、垃圾回收线程</p></blockquote><h3 id="二，创建线程"><a href="#二，创建线程" class="headerlink" title="二，创建线程"></a>二，创建线程</h3><h4 id="2-1-继承-Thread-类"><a href="#2-1-继承-Thread-类" class="headerlink" title="2.1 继承 Thread 类"></a>2.1 继承 Thread 类</h4><blockquote><p>步骤：</p><ol><li>定义类继承 Thread 类</li><li>重写 run() 方法，在 run() 方法中的功能就是线程要执行的功能</li><li>创建 Thread 的子类对象</li><li>调用 start() 方法开启线程，Java 虚拟机自动调用该线程的 run() 方法。</li></ol><p>注：同一个线程对象不能重复调用 start()，否则会发生 IllegalThreadStateException</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.start();</span><br><span class="line">        MyThread mt2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-----&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-2-实现-Runnable-接口"><a href="#2-2-实现-Runnable-接口" class="headerlink" title="2.2 实现 Runnable 接口"></a>2.2 实现 Runnable 接口</h4><blockquote><p>步骤：</p><ol><li>定义类实现 Runnable 接口</li><li>重写 run() 方法，在 run() 方法中的功能就是线程要执行的功能</li><li>创建该实现类的对象</li><li>创建 Thread 对象，并将实现类的对象作为参数传递给 Thread 的构造函数</li><li>调用 start() 方法开启线程，Java 虚拟机自动调用该线程的 run() 方法。</li></ol></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mr);</span><br><span class="line">        t.start();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mr);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-----&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>注：建议优先选用实现 Runnable 的方式，因为避免了单继承的局限性</p></blockquote><h4 id="2-3-使用匿名内部类创建线程并开启"><a href="#2-3-使用匿名内部类创建线程并开启" class="headerlink" title="2.3 使用匿名内部类创建线程并开启"></a>2.3 使用匿名内部类创建线程并开启</h4><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-----&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-----&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></blockquote><h3 id="三，线程安全问题"><a href="#三，线程安全问题" class="headerlink" title="三，线程安全问题"></a>三，线程安全问题</h3><blockquote><p>什么是线程安全：如果多个线程并发执行，这些线程操作共享数据，运行后的结果与单线程运行后的结果是相同的，就称为线程是安全的。</p><p>以下代码出现了线程安全问题：限制了ticket &gt; 0的条件，但是最终输出的ticket出现的0和负数，因为某条线程在执行的过程中被其他线程抢夺了CPU的执行权。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在卖第&quot;</span>+ (ticket)+<span class="string">&quot;号票&quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在卖第&quot;</span>+ (ticket)+<span class="string">&quot;号票&quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="四，同步技术"><a href="#四，同步技术" class="headerlink" title="四，同步技术"></a>四，同步技术</h3><blockquote><p>关键字：<code>synchronized</code></p></blockquote><h4 id="4-1-同步代码块"><a href="#4-1-同步代码块" class="headerlink" title="4.1 同步代码块"></a>4.1 同步代码块</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    <span class="comment">// 可能发生线程安全问题的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>同步代码块中的锁对象（同步锁）可以是任意类型的</li><li>必须保证多个线程使用的锁对象是同一个</li><li>锁对象的作用：将同步代码块锁定，同一时间只允许让一个线程进入同步代码块，只要有一个线程抢夺到了CPU的执行权，只有当该线程执行完毕后，其他线程才能继续抢夺CPU的执行权，否则就处于等待状态。</li></ol></blockquote><h4 id="4-2-同步函数"><a href="#4-2-同步函数" class="headerlink" title="4.2 同步函数"></a>4.2 同步函数</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> 返回类型 方法名(参数列表)&#123;</span><br><span class="line">    <span class="comment">// 可能发生线程安全问题的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li><p>同步函数中有锁对象吗？有，同步函数中的锁对象是 this</p></li><li><p>如果使用的是继承 Thread 的方式创建线程，同步函数必须是静态的</p><p>静态同步函数的锁对象是谁？锁是<code>类名.class</code> 二进制字节码文件对象</p></li></ol></blockquote><h4 id="4-3-Lock-锁"><a href="#4-3-Lock-锁" class="headerlink" title="4.3 Lock 锁"></a>4.3 Lock 锁</h4><blockquote><p>概念：Lock 是一个接口，在 JDK1.5 出现，Lock 实现提供了比使用 synchronized  方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构。</p><p>方法：</p><ol><li>lock()：获取锁</li><li>unlock()：释放锁</li></ol><p>步骤：</p><ol><li>在成员位置创建 Lock 接口的实现类对象 ReentrantLock</li><li>在可能发生线程安全问题的代码前调用 lock()</li><li>在可能发生线程安全问题的代码后调用 unlock()</li></ol></blockquote><blockquote><p>同步技术的原理：</p><p>同步技术中使用到的锁对象，这个锁对象也称为同步锁</p><p>多个线程一起抢夺CPU的执行权</p><p>​    获取到锁对象的线程，进入同步，当这个线程执行完同步中的代码后，释放锁；</p><p>​    没有获取到锁对象的线程，会处于阻塞状态，等待同步中的线程执行完毕后释放锁；</p><p>使用同步技术会影响程序的执行效率：</p><p>判断锁、获取锁、释放锁</p></blockquote><h3 id="五，线程池"><a href="#五，线程池" class="headerlink" title="五，线程池"></a>五，线程池</h3><blockquote><p>概念：线程池的本质就是一个容器，在该容器中存放着若干线程对象，当有任务需要使用线程对象时，直接从池中获取线程对象，当任务执行完毕后，将使用完的线程对象归还到池中，从而提高了线程对象的复用性，减少了线程对象的创建。</p><p>线程池的好处：</p><ol><li>减低了资源的消耗。减少了创建和销毁线程的次数，每个线程对象都可以被复用</li><li>提高了响应速度</li><li>提高了对线程的管理</li></ol></blockquote><blockquote><p>核心类：Executors，线程池的工厂类，用于生产线程池</p><p>Executors 类中提供了生产线程池的静态方法 newFixedThreadPool(int nThreads)，创建一个有固定数量线程对象的线程池，返回 ExecutorService 接口的实现类。</p><p>ExecutorService 接口中提供获取线程对象的功能 submit(Runnable r)，调用此功能会开启线程并执行 Runnable 实现类中的 run() 方法</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MyRunnable1 mr1 = <span class="keyword">new</span> MyRunnable1();</span><br><span class="line">MyRunnable2 mr2 = <span class="keyword">new</span> MyRunnable2();</span><br><span class="line">MyRunnable3 mr3 = <span class="keyword">new</span> MyRunnable3();</span><br><span class="line"></span><br><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">service.submit(mr1);</span><br><span class="line">service.submit(mr2);</span><br><span class="line">service.submit(mr3);</span><br><span class="line">service.shutdown();<span class="comment">// 关闭线程池</span></span><br></pre></td></tr></table></figure><p>注：</p><ol><li>如果要开启线程执行的任务超过池中线程对象的数量，没有执行的任务会等待其他任务执行完毕归还线程对象再执行它的任务</li><li>即使线程对象已经全部归还，线程池仍然处于开启状态，因为线程池在等待可能还有其他任务需要使用池中对象，我们可以手动调用 shutdown() 来强制关闭池，一旦池被关闭了，再从池中获取连接对象就会发生 RejectedExecutionException。</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一，概念&quot;&gt;&lt;a href=&quot;#一，概念&quot; class=&quot;headerlink&quot; title=&quot;一，概念&quot;&gt;&lt;/a&gt;一，概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;进程：正在运行的程序&lt;/p&gt;
&lt;p&gt;线程：是进程中的一个执行单元（一条执行路径），一个进程至少包含一条线程。如果一个进程包含多个线程，这种程序就叫多线程程序&lt;/p&gt;
&lt;p&gt;并发：两件事同时进行&lt;/p&gt;
&lt;p&gt;并行：两件事同时发生&lt;/p&gt;
&lt;p&gt;线程的调度：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分时调度：所有线程轮流使用CPU，每个线程平均分配CPU的执行权&lt;/li&gt;
&lt;li&gt;抢占式调度：优先让优先级高的线程执行，优先级相同时，CPU随机分配执行权，Java 中多线程的执行方式就是抢占式的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：Java 程序在没有额外开启线程的情况下也有两个线程：主函数所在的主线程、垃圾回收线程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二，创建线程&quot;&gt;&lt;a href=&quot;#二，创建线程&quot; class=&quot;headerlink&quot; title=&quot;二，创建线程&quot;&gt;&lt;/a&gt;二，创建线程&lt;/h3&gt;&lt;h4 id=&quot;2-1-继承-Thread-类&quot;&gt;&lt;a href=&quot;#2-1-继承-Thread-类&quot; class=&quot;headerlink&quot; title=&quot;2.1 继承 Thread 类&quot;&gt;&lt;/a&gt;2.1 继承 Thread 类&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义类继承 Thread 类&lt;/li&gt;
&lt;li&gt;重写 run() 方法，在 run() 方法中的功能就是线程要执行的功能&lt;/li&gt;
&lt;li&gt;创建 Thread 的子类对象&lt;/li&gt;
&lt;li&gt;调用 start() 方法开启线程，Java 虚拟机自动调用该线程的 run() 方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：同一个线程对象不能重复调用 start()，否则会发生 IllegalThreadStateException&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="后端编程" scheme="https://sweeneyzhou.top/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JAVA" scheme="https://sweeneyzhou.top/tags/JAVA/"/>
    
    <category term="学习笔记" scheme="https://sweeneyzhou.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础" scheme="https://sweeneyzhou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Thread" scheme="https://sweeneyzhou.top/tags/Thread/"/>
    
    <category term="Runnable接口" scheme="https://sweeneyzhou.top/tags/Runnable%E6%8E%A5%E5%8F%A3/"/>
    
    <category term="线程安全" scheme="https://sweeneyzhou.top/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
    <category term="同步技术" scheme="https://sweeneyzhou.top/tags/%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF/"/>
    
    <category term="同步代码块" scheme="https://sweeneyzhou.top/tags/%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
    <category term="同步函数" scheme="https://sweeneyzhou.top/tags/%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0/"/>
    
    <category term="Synchronized" scheme="https://sweeneyzhou.top/tags/Synchronized/"/>
    
    <category term="Lock锁" scheme="https://sweeneyzhou.top/tags/Lock%E9%94%81/"/>
    
    <category term="线程池" scheme="https://sweeneyzhou.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>文件操作、IO流</title>
    <link href="https://sweeneyzhou.top/%E6%96%87%E4%BB%B6%E3%80%81IO%E6%B5%81.html"/>
    <id>https://sweeneyzhou.top/%E6%96%87%E4%BB%B6%E3%80%81IO%E6%B5%81.html</id>
    <published>2021-04-21T01:01:41.864Z</published>
    <updated>2021-04-21T01:26:34.666Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一，File"><a href="#一，File" class="headerlink" title="一，File"></a>一，File</h3><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><blockquote><p>概念：文件和目录路径名的抽象表示形式。 </p></blockquote><h4 id="1-2-构造函数"><a href="#1-2-构造函数" class="headerlink" title="1.2 构造函数"></a>1.2 构造函数</h4><blockquote><ol><li>new File(String path)</li><li>new File(File parent，String path)</li><li>new File(String parent，String path)</li></ol><p>字段摘要：</p><p>File.separator：与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。</p></blockquote><h4 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h4><h5 id="1-3-1-创建和删除"><a href="#1-3-1-创建和删除" class="headerlink" title="1.3.1 创建和删除"></a>1.3.1 创建和删除</h5><blockquote><ol><li>createNewFile()：如果指定文件不存在，则创建一个指定文件名的文件，返回 true；如果已存在，则不创建，返回 false</li><li>mkdir()：创建一个文件夹（只能创建单层目录），返回 false 表示创建失败，true 表示成功</li><li>mkdirs()：创建一个文件夹（可以创建多级目录），返回 false 表示创建失败，true 表示成功</li><li>delete()：删除文件或者文件夹，，返回 false 表示删除失败，true 表示成功，如果文件夹中含有内容，那么该文件夹不能删除</li><li>deleteOnExit()：删除文件或者文件夹，在程序运行完毕后执行该删除操作，如果文件夹中含有内容，那么该文件夹不能删除</li></ol></blockquote><h5 id="1-3-2-判断相关"><a href="#1-3-2-判断相关" class="headerlink" title="1.3.2 判断相关"></a>1.3.2 判断相关</h5><blockquote><ol><li>exists()：判断文件或者文件夹是否存在</li><li>isFile()：判断是否是文件</li><li>isDirectory()：判断是否是目录</li></ol><p>注：如果文件或者文件夹不存在，那么无论是判断是文件还是目录返回的都是 false</p><ol start="4"><li>canRead()：判断是否可读</li><li>canWrite()：判断是否可写</li><li>canExecute()：判断是否可执行，只有 linux 操作系统下有效</li><li>isHidden()：判断文件或者文件夹是否隐藏</li></ol></blockquote><h5 id="1-3-3-获取相关"><a href="#1-3-3-获取相关" class="headerlink" title="1.3.3 获取相关"></a>1.3.3 获取相关</h5><blockquote><ol><li>getPath()：获取路径，返回结果与创建时的路径表示形式相同</li><li>getAbsolutePath()：获取绝对路径，无论创建时使用的是相对路径还是绝对路径，返回的都是绝对路径</li><li>getParent()：返回父目录的地址，如果是以相对路径的写法创建文件对象，那么返回的结果是null</li><li>getParentFile()：返回父目录文件的对象</li><li>getName()：返回文件名（包含后缀）</li><li>length()：返回文件大小，单位是字节</li></ol></blockquote><h5 id="1-3-4-遍历目录"><a href="#1-3-4-遍历目录" class="headerlink" title="1.3.4 遍历目录"></a>1.3.4 遍历目录</h5><blockquote><ol><li>list()：返回指定目录下所有文件或者文件夹的名字组成的数组</li><li>listFiles()：返回指定目录下所有文件对象组成的数组</li><li>list(FilenameFilter filter)：根据指定的文件名过滤器获取指定文件，将它们的名字组成数组</li><li>listFile(FilenameFilter filter)：根据指定的文件名过滤器获取指定文件，将这些文件对象组成数组</li></ol></blockquote><h4 id="1-4-文件过滤"><a href="#1-4-文件过滤" class="headerlink" title="1.4 文件过滤"></a>1.4 文件过滤</h4><blockquote><ol><li><p>实现 FileNameFilter 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> * 1.dir：调用listFiles的目录对象</span></span><br><span class="line"><span class="comment"> * 2.name：当前目录下的所有文件的文件名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name.endsWith(<span class="string">&quot;mp3&quot;</span>)||name.endsWith(<span class="string">&quot;wma&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现 FileFilter 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File[] fss = f.listFiles(<span class="keyword">new</span> FileFilter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pathname.getName().endsWith(<span class="string">&quot;txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(fss.length);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="1-5-目录的遍历（递归）"><a href="#1-5-目录的遍历（递归）" class="headerlink" title="1.5 目录的遍历（递归）"></a>1.5 目录的遍历（递归）</h4><blockquote><p>递归：在方法中直接或者间接的调用自身</p><p>注：</p><ol><li>递归要有结束的条件，保证递归能够停止，否则会发生 StackOverflowError 栈溢出</li><li>在不断递归的过程中，数据规模要不断减小</li><li>递归的性能较差</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(File dir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">            <span class="keyword">if</span>(file.getName().endsWith(<span class="string">&quot;txt&quot;</span>))&#123;</span><br><span class="line">                fileList.add(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            search(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="二，IO流"><a href="#二，IO流" class="headerlink" title="二，IO流"></a>二，IO流</h3><h4 id="2-1-什么是IO流"><a href="#2-1-什么是IO流" class="headerlink" title="2.1 什么是IO流"></a>2.1 什么是IO流</h4><blockquote><p>我们把数据的传输看成是一种数据的流动，按照流向进行划分分为输入流（input）和输出流（output）</p><p>IO流的分类</p><p>根据数据的流向划分：</p><ol><li>输入流：把数据从其他设备读取到内存中（外 -&gt; 内）</li><li>输出流：把数据从内存中写到其他设备上（内 -&gt; 外）</li></ol><p>根据数据的类型划分：</p><ol><li>字节流：以字节为单位，任何文件</li><li>字符流：以字符为单位，文本文件&gt;</li></ol></blockquote><blockquote><p>IO流的顶层父类（抽象类）</p><ol><li>字节输入流：InputStream</li><li>字节输出流：OutputStream</li><li>字符输入流：Reader</li><li>字符输出流：Writer</li></ol></blockquote><h4 id="2-2-FileOutputStream-文件字节输出流"><a href="#2-2-FileOutputStream-文件字节输出流" class="headerlink" title="2.2 FileOutputStream 文件字节输出流"></a>2.2 FileOutputStream 文件字节输出流</h4><blockquote><p>构造方法：</p><ol><li>new FileOutputStream(File f)：根据指定文件对象所指向的文件路径创建文件字节输出流对象</li><li>new FileOutputStream(String name)：根据指定文件路径创建文件字节输出流对象</li><li>new FileOutputStream(File f，boolean b)：功能同上，第二个参数值为 true 时，表示该文件可以续写</li><li>new FileOutputStream(String name，boolean b)：功能同上，第二个参数值为 true 时，表示该文件可以续写</li></ol></blockquote><blockquote><p>常用方法：</p><ol><li>close()：释放资源，如果执行了 close() 方法，那么就不能在写入了</li><li>flush()：刷新缓冲区</li><li>write(int ch)：根据十进制数写入对应的字符</li><li>writer(byte[] b)：写入指定的字节数组，如果要写入字符串，可以通过，字符串的 getBytes() 方法获取对应的字节数组</li><li>writer(byte[] b，int index ，int lenth)：从字节数组中的指定位置获取指定数量的元素写入到文件中</li></ol></blockquote><h4 id="2-3-FileInputStream-文件字节输入流"><a href="#2-3-FileInputStream-文件字节输入流" class="headerlink" title="2.3 FileInputStream 文件字节输入流"></a>2.3 FileInputStream 文件字节输入流</h4><blockquote><p>构造函数</p><ol><li>new FileInputStream(File f)：根据指定文件对象所指向的文件路径创建文件字节输入流对象</li><li>new FileInputStream(String name)：根据指定文件路径创建文件字节输入流对象</li></ol></blockquote><blockquote><p>常用方法</p><ol><li>read()：读取单个字符所对应的十进制数，返回 -1 表示读完了</li><li>read(byte b[]，int a，int b)：从指定文件中的a位置开始，读取b个字符，存储到数组中</li><li>read(byte b[])：从指定文件中读取还未获取到的字符，存储到数组中，返回读取到的有效个数</li><li>close()：释放资源</li></ol></blockquote><h4 id="2-4-FileWriter-文件字符输出流"><a href="#2-4-FileWriter-文件字符输出流" class="headerlink" title="2.4 FileWriter 文件字符输出流"></a>2.4 FileWriter 文件字符输出流</h4><blockquote><p>构造函数</p><ol><li>new FileWriter(File f)</li><li>new FileWriter(String name)</li><li>new FileWriter(File f，boolean b)</li><li>new FileWriter(String name，boolean b)</li></ol></blockquote><blockquote><p>常用方法</p><ol><li>close()：释放资源，执行释放动作前，会先将缓冲区中的数据刷新到的目标位置</li><li>flush()：当使用 write() 方法写入文件时，只是把数据写入到了缓冲区中，需要用 flush() 才能将数据从缓冲区中真正的刷新到目标位置</li><li>write(int ch)</li><li>write(String str)</li><li>write(String str，int index，int length)</li><li>write(char[] ch)</li><li>write(char[] ch，int index，int length)</li></ol></blockquote><h4 id="2-5-FileReader-文件字符输入流"><a href="#2-5-FileReader-文件字符输入流" class="headerlink" title="2.5 FileReader 文件字符输入流"></a>2.5 FileReader 文件字符输入流</h4><blockquote><p>构造函数</p><ol><li>new FileReader(File f)</li><li>new FileReader(String name)</li></ol></blockquote><blockquote><p>常用方法</p><ol><li>read()</li><li>read(char ch[])</li><li>read(char ch[] ，int index，int lenth)</li><li>close()</li></ol></blockquote><h4 id="2-6-缓冲流"><a href="#2-6-缓冲流" class="headerlink" title="2.6 缓冲流"></a>2.6 缓冲流</h4><blockquote><p>概念：也称作高效流，它是对文件流的增强</p><p>效率高的原因：在进行IO操作时，内置一个缓冲区数组，通过缓冲区数组来减少对文件的IO操作次数，从而提高效率。</p><p>分类：</p><ol><li>BufferedReader：字符缓冲输入流</li><li>BufferedWriter：字符缓冲输出流</li><li>BufferedInputStream：字节缓冲输入流</li><li>BufferedOutputStream：字节缓冲输出流</li></ol></blockquote><blockquote><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(Reader r);</span><br><span class="line"></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(Writer w);</span><br><span class="line"></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(InputStream is);</span><br><span class="line"></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(OutputStream os);</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>方法：缓冲流中的方法和普通文件流中的方法相同</p><p>特有方法：</p><ol><li>BufferedReader 中 readLine()：读取一整行</li><li>BufferedWriter 中 newLine()：写入一个换行</li></ol></blockquote><h4 id="2-7-对象流（序列化流）"><a href="#2-7-对象流（序列化流）" class="headerlink" title="2.7 对象流（序列化流）"></a>2.7 对象流（序列化流）</h4><blockquote><p>Java 中提供了一种对象的序列化机制，允许将一个对象及其属性持久化到文件中</p><p>序列化：将对象存储到文件中</p><p>反序列化：将文件中的对象解析出来</p><p>ObjectOutputStream</p><p>构造函数：new ObjectOuputStream(OutputStream os)</p><p>ObjectInputStream</p><p>构造函数：new new ObjectInputStream(InputStream is);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Emp e = <span class="keyword">new</span> Emp();</span><br><span class="line">e.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">e.setAge(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\86151\\Desktop\\test\\d.txt&quot;</span>);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">oos.writeObject(e);</span><br><span class="line"></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\86151\\Desktop\\test\\d.txt&quot;</span>);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">Emp emp = (Emp)ois.readObject();</span><br><span class="line">System.out.println(emp.getName());</span><br><span class="line">System.out.println(emp.getAge());</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>一个类的对象要被序列化，该类必须实现 Serializable ，该接口是一个标记接口，不需要重写方法，否则会发生 NotSerializableException</li><li>如果读取对象的次数超过了对象的个数会发生 EOFException</li><li>如果不想让某个属性被序列化，需要使用关键字<code>transient</code>(瞬态的)</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一，File&quot;&gt;&lt;a href=&quot;#一，File&quot; class=&quot;headerlink&quot; title=&quot;一，File&quot;&gt;&lt;/a&gt;一，File&lt;/h3&gt;&lt;h4 id=&quot;1-1-概念&quot;&gt;&lt;a href=&quot;#1-1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 概念&quot;&gt;&lt;/a&gt;1.1 概念&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;概念：文件和目录路径名的抽象表示形式。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-2-构造函数&quot;&gt;&lt;a href=&quot;#1-2-构造函数&quot; class=&quot;headerlink&quot; title=&quot;1.2 构造函数&quot;&gt;&lt;/a&gt;1.2 构造函数&lt;/h4&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;new File(String path)&lt;/li&gt;
&lt;li&gt;new File(File parent，String path)&lt;/li&gt;
&lt;li&gt;new File(String parent，String path)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;字段摘要：&lt;/p&gt;
&lt;p&gt;File.separator：与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="后端编程" scheme="https://sweeneyzhou.top/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JAVA" scheme="https://sweeneyzhou.top/tags/JAVA/"/>
    
    <category term="学习笔记" scheme="https://sweeneyzhou.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础" scheme="https://sweeneyzhou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="File" scheme="https://sweeneyzhou.top/tags/File/"/>
    
    <category term="IO" scheme="https://sweeneyzhou.top/tags/IO/"/>
    
    <category term="流" scheme="https://sweeneyzhou.top/tags/%E6%B5%81/"/>
    
    <category term="InputStream" scheme="https://sweeneyzhou.top/tags/InputStream/"/>
    
    <category term="OutputStream" scheme="https://sweeneyzhou.top/tags/OutputStream/"/>
    
    <category term="文件输入输出流" scheme="https://sweeneyzhou.top/tags/%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    
    <category term="FileOutputStream" scheme="https://sweeneyzhou.top/tags/FileOutputStream/"/>
    
    <category term="FileInputStream" scheme="https://sweeneyzhou.top/tags/FileInputStream/"/>
    
    <category term="FileWriter" scheme="https://sweeneyzhou.top/tags/FileWriter/"/>
    
    <category term="FileReader" scheme="https://sweeneyzhou.top/tags/FileReader/"/>
    
    <category term="缓冲流" scheme="https://sweeneyzhou.top/tags/%E7%BC%93%E5%86%B2%E6%B5%81/"/>
    
    <category term="BufferedInputStream" scheme="https://sweeneyzhou.top/tags/BufferedInputStream/"/>
    
    <category term="BufferedOutputStream" scheme="https://sweeneyzhou.top/tags/BufferedOutputStream/"/>
    
    <category term="BufferedReader" scheme="https://sweeneyzhou.top/tags/BufferedReader/"/>
    
    <category term="BufferedWriter" scheme="https://sweeneyzhou.top/tags/BufferedWriter/"/>
    
    <category term="对象流" scheme="https://sweeneyzhou.top/tags/%E5%AF%B9%E8%B1%A1%E6%B5%81/"/>
    
    <category term="ObjectInputStream" scheme="https://sweeneyzhou.top/tags/ObjectInputStream/"/>
    
    <category term="ObjectOutputStream" scheme="https://sweeneyzhou.top/tags/ObjectOutputStream/"/>
    
    <category term="序列化" scheme="https://sweeneyzhou.top/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="序列化接口" scheme="https://sweeneyzhou.top/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3/"/>
    
    <category term="Serializable" scheme="https://sweeneyzhou.top/tags/Serializable/"/>
    
    <category term="瞬态" scheme="https://sweeneyzhou.top/tags/%E7%9E%AC%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>集合</title>
    <link href="https://sweeneyzhou.top/%E9%9B%86%E5%90%88.html"/>
    <id>https://sweeneyzhou.top/%E9%9B%86%E5%90%88.html</id>
    <published>2021-04-21T01:01:41.835Z</published>
    <updated>2021-04-21T01:17:33.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一，概念"><a href="#一，概念" class="headerlink" title="一，概念"></a>一，概念</h3><blockquote><p>集合是一种容器</p><p>特点：</p><ol><li>集合的长度是可变的</li><li>同一个集合中可以存储不同数据类型的值</li><li>可以通过泛型来明确集合中存储的数据类型，一旦指定了泛型，那么该集合就只能存储这种数据类型了</li><li>集合找那个只能存储引用数据类型，不能存储基本数据类型，如果要在集合中存储基本数据类型，要使用基本数据类型的包装类</li></ol></blockquote><h3 id="二，集合的体系"><a href="#二，集合的体系" class="headerlink" title="二，集合的体系"></a>二，集合的体系</h3><blockquote><p>Collection：集合的顶层父接口，提供了集合的基本操作</p><p>List：接口，有序可重复</p><p>​    ArrayList：数组结构</p><p>​    LinkedList：链表结构</p><p>Set：接口，不可重复</p><p>​    HashSet：哈希表</p><p>​    TreeSet：树形结构</p><p>​    LinkedHashSet：链表+哈希表</p></blockquote><h3 id="三，List集合"><a href="#三，List集合" class="headerlink" title="三，List集合"></a>三，List集合</h3><blockquote><p>概念：List 集合是Collection 接口的一个子接口</p><p>特点：</p><ol><li>允许重复元素</li><li>有序的集合</li></ol></blockquote><h4 id="3-1-ArrayList-集合"><a href="#3-1-ArrayList-集合" class="headerlink" title="3.1 ArrayList 集合"></a>3.1 ArrayList 集合</h4><blockquote><p>概念：ArrayList 集合是 List 接口的一个数组结构的实现类。有序可重复。</p></blockquote><blockquote><p>构造函数：</p><ol><li>new ArrayList()：构造一个初始容量为 10 的空列表</li><li>new ArrayList(int capacity)：构造一个具有指定初始容量的空列表</li><li>new ArrayList(Collection&lt;? extends E&gt; c)：根据参数集合构造一个新集合，参数集合的泛型必须是当前所创建集合泛型的类型或它的子类（设置泛型的上限）</li></ol></blockquote><blockquote><p>常用方法：</p><ol><li>add(E e)：将元素添加到集合的末尾，返回布尔值；如果是 List 的 add() 返回值一定是 true，如果是 Set 的add() ，当元素已存在时会返回 false    </li><li>add(int index,  E e)：将元素添加集合中的指定位置，返回 void</li><li>remove(E e)：从集合中移除指定对象，返回是否移除成功的布尔值</li><li>remove(int index)：从集合中移除指定位置上的对象，返回被移除的对象</li><li>set(int index, E e)：用指定元素替换集合中指定位置上的元素</li><li>get(int index)：通过下标返回元素</li><li>size()：返回集合的大小</li><li>addAll(Collecrtion c)</li><li>addAll(int index, Collection c)</li><li>containsAll(Collection c)：判断参数集合中的所有元素是否都存在于调用者集合中</li><li>a . retainAll( b )：将 a、b两个集合的交集替换掉 a 集合中的所有元素，返回 true 表示 a 集合发生了改变</li><li>a . removeAll( b )：从 a 集合中移除 a、b 集合的交集，返回 true 表示 a 集合发生了改变</li><li>clear()</li><li>contains(E e)</li><li>indexOf(Object o)</li><li>lastIndexOf(Object o)</li><li>isEmpty()</li></ol></blockquote><h4 id="3-2-LinkedList-集合"><a href="#3-2-LinkedList-集合" class="headerlink" title="3.2 LinkedList 集合"></a>3.2 LinkedList 集合</h4><blockquote><p>概念：LinkedList 集合是 List 接口的一个实现类，它的存储结构是链表结构，LinkedList 的特点是增删快，查询慢。</p></blockquote><blockquote><p>注：在 ArrayList 中所具备的方法，在 LinkedList 中都有，如果想要调用 LinkedList 中的特有方法，不可以使用多态的形式创建 LinkedList 对象。</p><p>LinkedList 的特有方法：</p><ol><li>addFirst(E e)</li><li>addLast(E e)</li><li>remove()</li><li>removeFirst()</li><li>removeLast()</li><li>peek()</li><li>peekFirst()</li><li>peekLast()</li><li>pop()</li><li>poll()</li><li>push(E e)</li></ol></blockquote><h3 id="四，Set-集合"><a href="#四，Set-集合" class="headerlink" title="四，Set 集合"></a>四，Set 集合</h3><blockquote><p>概念：Set 集合是Collection 接口的一个子接口</p><p>特点：</p><ol><li>不允许重复元素</li><li>没有下标，没有使用下标作为参数的相关方法，因此 Set 集合不能使用普通for循环遍历</li></ol></blockquote><h4 id="4-1-HashSet-集合"><a href="#4-1-HashSet-集合" class="headerlink" title="4.1 HashSet 集合"></a>4.1 HashSet 集合</h4><blockquote><p>概念：HashSet 集合 Set 接口的一个实现类</p><p>特点：</p><ol><li>无序，存取顺序不保证一致</li><li>不允许有重复元素</li><li>没有下标，没有使用下标作为参数的相关方法，因此 Set 集合不能使用普通for循环遍历</li><li>底层的数据结构是哈希表，哈希表的特点是查询快<ol><li>java8之前，哈希表 = 数组 + 链表</li><li>java8及之后，哈希表 = 数组 + 链表（当链表的长度超过8个时，链表会转换成红黑树）</li></ol></li></ol></blockquote><blockquote><p>存储原理：</p><p>向HashSet存储数据时，会判断集合中是否已经存在与要存储的数据具有相同哈希值的元素，如果没有，则直接存储。如果有，则会使用equals来比较，如果结果为true，则不存储，结果为false，则存储。</p></blockquote><blockquote><p>构造函数：</p><ol><li>new HashSet()：构造一个初始容量为 16 的空列表</li><li>new HashSet(int capacity)：构造一个具有指定初始容量的空列表</li><li>new HashSet(Collection&lt;? extends E&gt; c)：根据参数集合构造一个新集合，参数集合的泛型必须是当前所创建集合泛型的类型或它的子类（设置泛型的上限）</li></ol></blockquote><h4 id="4-2-TreeSet-集合"><a href="#4-2-TreeSet-集合" class="headerlink" title="4.2 TreeSet 集合"></a>4.2 TreeSet 集合</h4><blockquote><p>概念：TreeSet 是 Set 接口的一个实现类</p><p>特点：</p><ol><li>无序，存取顺序不保证一致</li><li>不允许有重复元素</li><li>没有下标，没有使用下标作为参数的相关方法，因此 Set 集合不能使用普通for循环遍历</li><li>能实现自动排序</li></ol><p>注：</p><ol><li><p>如果TreeSet中存储的是自定义数据类型，那么该类必须实现Comparable接口，否则会发生 ClassCastException</p></li><li><p>如果自定义的排序方式中属性的差值为0，那么在TreeSet中会视为是同一个对象，由于Set不能存储重复元素，因此只会存储一个。</p></li></ol><p>解决办法：</p><ol><li>多条件的排序，第一个条件相同时，对第二个条件进行排序</li><li>使用允许存储重复元素的List集合，实现 Comparable 接口，重写 compareTo() 方法，使用 Collections 的sort() 方法进行排序</li></ol></blockquote><blockquote><p>构造函数：</p><ol><li><p>new TreeSet()：构造一个新的空 set，该 set 根据其元素的自然顺序进行排序</p></li><li><p>new TreeSet(Comparator c)：构造一个新的空 TreeSet，它根据指定比较器进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Doctor&gt; ds = <span class="keyword">new</span> TreeSet&lt;Doctor&gt;(<span class="keyword">new</span> Comparator&lt;Doctor&gt;()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Doctor d1,Doctor d2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> d2.num - d1.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>new TreeSet(Collection&lt;? extends E&gt; c)：根据参数集合构造一个新集合，参数集合的泛型必须是当前所创建集合泛型的类型或它的子类（设置泛型的上限）</p></li></ol></blockquote><h4 id="4-3-LinkedHashSet-集合"><a href="#4-3-LinkedHashSet-集合" class="headerlink" title="4.3 LinkedHashSet 集合"></a>4.3 LinkedHashSet 集合</h4><blockquote><p>概念：LinkedHashSet 是 Set 接口的一个实现类</p><p>特点：</p><ol><li><p>LinkedHashSet 的数据结构是哈希表加上链表，它在 HashSet 的基础上添加了一条链表来保存元素的存储顺序，因此 LinkedHashSet 的有序的</p></li><li><p>有序，保证存取顺序一致</p></li><li><p>没有下标，没有使用下标作为参数的相关方法，因此 Set 集合不能使用普通for循环遍历</p></li></ol></blockquote><blockquote><p>构造函数：</p><ol><li>new LinkedHashSet()：构造一个初始容量为 16 的空列表</li><li>new LinkedHashSet(int capacity)：构造一个具有指定初始容量的空列表</li><li>new LinkedHashSet(Collection&lt;? extends E&gt; c)：根据参数集合构造一个新集合，参数集合的泛型必须是当前所创建集合泛型的类型或它的子类（设置泛型的上限）</li></ol></blockquote><h3 id="五，迭代器"><a href="#五，迭代器" class="headerlink" title="五，迭代器"></a>五，迭代器</h3><blockquote><p>概念：迭代器是遍历集合元素的通用方法</p><p>原理：先判断是否有下一个可以迭代的元素，如果没有，则不获取，迭代结束；如果有，则获取下一次元素。继续判断。</p><p>可迭代的接口：Iterable，提供了 iterator() 方法用于获取迭代器对象</p><p>迭代器接口：Iterator，提供了两个方法：</p><ol><li>hasNext()：判断集合中是否存在下一个可获取的元素，返回布尔值</li><li>next()：获取下一个元素</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;贾宝玉&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;林黛玉&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;薛宝钗&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; it = list.iterator();it.hasNext();)&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="六，Collecctions"><a href="#六，Collecctions" class="headerlink" title="六，Collecctions"></a>六，Collecctions</h3><blockquote><p>概念：Collecctions 由在 集合 上进行操作或返回 集合 的静态方法组成。</p><p>常用方法：</p><ol><li><p>addAll(Collection&lt;? super T&gt;     c ，T   …  e)：将可变参数 e 中的所有元素添加到集合 c 中</p></li><li><p>binarySearch(List l，T t)：使用二分搜索法查询集合中指定元素的下标，</p><p>前提是：1.升序排列 2.没有重复元素</p></li><li><p>binarySearch(List l，T t，Comparator c)</p></li><li><p>copy(List a，List b)：将 b 集合中的所有元素赋值到 a 集合从第一个元素开始，如果 a 的长度小于 b 的长度会发生 IndexOutOfBoundsException</p></li><li><p>fill(List l，T … t)：使用 t 替换 集合中的所有元素</p></li><li><p>max(Collection c)：获取集合中最大值</p></li><li><p>min(Collection c)：获取集合中最小值</p><p>如果要获取自定义类型中对象属性的最大最小值，可以使用重载形式：</p><p>max(Collection c，Comparator c)、min(Collection c，Comparator c)</p></li><li><p>replaceAll(List l，T oldValue，T newValue)：使用 newValue 替换 list 中的所有 oldValue</p></li><li><p>*reverse()：倒置</p></li><li><p>*swap(List l，int i，int j)：将集合中下标 i 和下标 j 位置上的元素交换</p></li><li><p>*shuffle(List l)：打乱集合</p></li><li><p>*sort(List l)：字符串和基本类型默认按照字典顺序排序，自定义数据类型的属性排序时需要实现 Comparable 接口</p></li><li><p>*sort(List l，Comparator c)：字符串和基本类型默认按照字典顺序排序，自定义数据类型的属性排序时，需要传入 Comparator 的实现类对象。</p></li></ol></blockquote><h3 id="七，Map"><a href="#七，Map" class="headerlink" title="七，Map"></a>七，Map</h3><h4 id="7-1-概念和特点"><a href="#7-1-概念和特点" class="headerlink" title="7.1 概念和特点"></a>7.1 概念和特点</h4><blockquote><p>Collection 单列集合</p><p>Map 是双列集合，在 Map 中存储元素时，要将一个元素以键值对的一一对应的映射关系存储到集合中</p><p>Map的特点：</p><ol><li>Map 中的一个元素包含两个部分：键（key）、值（value）</li><li>key 和 value 的类型的任意的</li><li>key 是唯一的，value 是可以重复</li><li>Map 中存储的是映射关系，该映射关系由键和对应的值产生</li><li>Map 没有下标</li></ol></blockquote><h4 id="7-2-Map-的方法"><a href="#7-2-Map-的方法" class="headerlink" title="7.2 Map 的方法"></a>7.2 Map 的方法</h4><blockquote><ol><li>put(k，v)：将 k、v形成的键值对添加到集合中，当 key 重复时，返回被替换的 value</li><li>remove(k)：将键所对应的键值对删除，返回被删除的值</li><li>remove(k，v)：只有当k、v的映射关系存在集合于中才会删除</li><li>replace(k，v)：将 v 替换指定 k 上的值</li><li>replace(key，oldValue，newValue)：只有当 key 和 oldValue 的映射关系存在集合于中才会将 newValue 替换掉 oldValue</li><li>get(k)：根据键返回对应的值</li><li>size()：返回集合的大小</li><li>clear()：清空集合</li><li>containsValue(v)：判断是否存在指定的值</li><li>containsKey(k)：判断是否存在指定的键</li><li>isEmpty()：判断集合是否为空</li><li>equals(map)：比较两个 Map 中的元素是否完全相同</li><li>values()：返回 Map 中值组成 Collection 集合</li><li>keySet()：获取 Map 中所有键组成的 Set 集合</li><li>entrySet()：获取 Map 中所有映射关系组成的 Set 集合</li></ol></blockquote><p>z</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一，概念&quot;&gt;&lt;a href=&quot;#一，概念&quot; class=&quot;headerlink&quot; title=&quot;一，概念&quot;&gt;&lt;/a&gt;一，概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;集合是一种容器&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;集合的长度是可变的&lt;/li&gt;
&lt;li&gt;同一个集合中可以存储不同数据类型的值&lt;/li&gt;
&lt;li&gt;可以通过泛型来明确集合中存储的数据类型，一旦指定了泛型，那么该集合就只能存储这种数据类型了&lt;/li&gt;
&lt;li&gt;集合找那个只能存储引用数据类型，不能存储基本数据类型，如果要在集合中存储基本数据类型，要使用基本数据类型的包装类&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二，集合的体系&quot;&gt;&lt;a href=&quot;#二，集合的体系&quot; class=&quot;headerlink&quot; title=&quot;二，集合的体系&quot;&gt;&lt;/a&gt;二，集合的体系&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Collection：集合的顶层父接口，提供了集合的基本操作&lt;/p&gt;
&lt;p&gt;List：接口，有序可重复&lt;/p&gt;
&lt;p&gt;​    ArrayList：数组结构&lt;/p&gt;
&lt;p&gt;​    LinkedList：链表结构&lt;/p&gt;
&lt;p&gt;Set：接口，不可重复&lt;/p&gt;
&lt;p&gt;​    HashSet：哈希表&lt;/p&gt;
&lt;p&gt;​    TreeSet：树形结构&lt;/p&gt;
&lt;p&gt;​    LinkedHashSet：链表+哈希表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三，List集合&quot;&gt;&lt;a href=&quot;#三，List集合&quot; class=&quot;headerlink&quot; title=&quot;三，List集合&quot;&gt;&lt;/a&gt;三，List集合&lt;/h3&gt;</summary>
    
    
    
    <category term="后端编程" scheme="https://sweeneyzhou.top/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JAVA" scheme="https://sweeneyzhou.top/tags/JAVA/"/>
    
    <category term="学习笔记" scheme="https://sweeneyzhou.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础" scheme="https://sweeneyzhou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="集合" scheme="https://sweeneyzhou.top/tags/%E9%9B%86%E5%90%88/"/>
    
    <category term="Collection" scheme="https://sweeneyzhou.top/tags/Collection/"/>
    
    <category term="List" scheme="https://sweeneyzhou.top/tags/List/"/>
    
    <category term="ArrayList" scheme="https://sweeneyzhou.top/tags/ArrayList/"/>
    
    <category term="LinkedList" scheme="https://sweeneyzhou.top/tags/LinkedList/"/>
    
    <category term="Set" scheme="https://sweeneyzhou.top/tags/Set/"/>
    
    <category term="HashSet" scheme="https://sweeneyzhou.top/tags/HashSet/"/>
    
    <category term="TreeSet" scheme="https://sweeneyzhou.top/tags/TreeSet/"/>
    
    <category term="LinkedHashSet" scheme="https://sweeneyzhou.top/tags/LinkedHashSet/"/>
    
    <category term="Map" scheme="https://sweeneyzhou.top/tags/Map/"/>
    
    <category term="HashMap" scheme="https://sweeneyzhou.top/tags/HashMap/"/>
    
    <category term="迭代器" scheme="https://sweeneyzhou.top/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>常用类</title>
    <link href="https://sweeneyzhou.top/%E5%B8%B8%E7%94%A8%E7%B1%BB.html"/>
    <id>https://sweeneyzhou.top/%E5%B8%B8%E7%94%A8%E7%B1%BB.html</id>
    <published>2021-04-21T01:01:41.833Z</published>
    <updated>2021-04-21T01:17:40.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一，Scanner"><a href="#一，Scanner" class="headerlink" title="一，Scanner"></a>一，Scanner</h3><blockquote><p>Scanner 是一个专门用于接收键盘输入的类，它在 java.util 包中</p><p>构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Scanner(System.in)</span><br></pre></td></tr></table></figure><p>常用方法：</p><ol><li><p>next()</p></li><li><p>nextLine()</p></li><li><p>nextInt()</p></li><li><p>nextInt(int radix)</p><p>例如：nextInt(2)，表示系统将输入的内容视为二进制数，返回一个对应的十进制数</p></li><li><p>nextDouble()</p></li></ol><p>注：如果输入内容的类型与指定类型不匹配会发生 <code>InputMismatchException</code></p></blockquote><h3 id="二，Random"><a href="#二，Random" class="headerlink" title="二，Random"></a>二，Random</h3><blockquote><p>Random 是一个专门用于产生随机数的类，它在 java.util 包中</p><p>构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Random()</span><br></pre></td></tr></table></figure><p>常用方法：</p><ol><li><p>nextInt()：随机整个 int 范围内的数</p></li><li><p>nextDouble：随机 [0.0，1.0)</p></li><li><p>nextInt(int bound)：随机 [0，bound)</p><p>例如：随机 [44，55] ，nextInt(55-44+1)+44</p></li></ol></blockquote><h3 id="三，Math"><a href="#三，Math" class="headerlink" title="三，Math"></a>三，Math</h3><blockquote><p>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。它在 java.util 包中</p><p>注：</p><ol><li>Math 类是最终类，不能被继承</li><li>Math 类的构造函数私有化了，其他类无法创建 Math 类的对象</li><li>Math 类中成员都是静态的</li></ol></blockquote><blockquote><p>静态常量：</p><ol><li>E：自然对数的底数</li><li>PI：圆周率</li></ol></blockquote><blockquote><p>常用方法：</p><ol><li>abs(double d)：求绝对值</li><li>ceil(double d)：向上取整</li><li>floor(double d)：向下取整</li><li>toDegrees(double d)：弧度制转角度制</li><li>toRadians(double d)：角度制转弧度制</li><li>sin(double d)：求正弦值，参数是弧度制的</li><li>acos(double d)：求反余弦值</li><li>max(double d，double d)：求较大者</li><li>min(double d，double d)：求较小者</li><li>pow(double a，double b)：求a的b次方</li><li>sqrt(double d)：求平方根</li><li>random()：随机 [0.0，1.0)</li><li>round(double d)：四舍五入，返回long值</li><li>rint(double d)：四舍五入，返回double值</li></ol></blockquote><h3 id="四，Date"><a href="#四，Date" class="headerlink" title="四，Date"></a>四，Date</h3><blockquote><p>类 Date 表示特定的瞬间，精确到毫秒，它在 java.util 包中</p><p>Date类的功能：</p><ol><li>可以将Date对象转换成时间字段</li><li>可以将Date对象进行格式化和解析</li></ol><p>构造函数：</p><ol><li>new Date()：获取当前时间</li><li>new Date(long d)：获取指定时间，从1970 年 1 月 1 日 00:00:00 GMT开始</li></ol><p>常用方法：</p><ol><li>getTime()：返回1970 年 1 月 1 日 00:00:00 到Date对象的所指定的时间</li></ol></blockquote><h3 id="五，DateFormat"><a href="#五，DateFormat" class="headerlink" title="五，DateFormat"></a>五，DateFormat</h3><blockquote><p>DateFormat是一个抽象类，通常使用它的子类 SimpleDateFormat </p><p>SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。</p><p>它允许进行格式化（日期 -&gt;  文本）、解析（文本 -&gt; 日期）和规范化</p><p>构造函数：</p><ol><li>new SimpleDateFormat(String pattern)：根据指定格式模式创建对象</li></ol><p>功能：</p><ol><li>格式化（Date对象 - &gt; String）</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">format</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建日期对象</span></span><br><span class="line">    Date d = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="comment">// 创建日期格式化对象，同时指定格式</span></span><br><span class="line">    DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用format方法对指定的日期对象执行格式化</span></span><br><span class="line">    String time = df.format(d);</span><br><span class="line">    System.out.println(time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>解析（String - &gt; Date对象）</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    Date d = df.parse(<span class="string">&quot;2021-04-06 16:57:04&quot;</span>);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果日期字符串与指定格式不匹配，会发生ParseException</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="六，Calendar"><a href="#六，Calendar" class="headerlink" title="六，Calendar"></a>六，Calendar</h3><blockquote><p>概念：Calendar 类是一个抽象类，它为特定瞬间与日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法。瞬间可用毫秒值来表示。它是距格林威治标准时间 1970 年 1 月 1 日的 00:00:00 的偏移量。 </p><p><code>Calendar</code> 的 <code>getInstance</code> 方法返回一个 <code>Calendar</code>  对象，其日历字段已由当前日期和时间初始化</p><p>对象获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();</span><br></pre></td></tr></table></figure><p>常用方法：</p><ol><li>get(int field)：返回指定日历字段的值</li><li>set(int field，int value)：为指定日历的字段设置值</li><li>set(int year，int month，int date，int hourOfDay，int minute，int second)</li><li>getTime()：返回 Date 对象</li><li>getTimeInMillis()：返回1970 年 1 月 1 日 00:00:00到Calendar对象的所指定的时间</li></ol></blockquote><h3 id="七，Arrays"><a href="#七，Arrays" class="headerlink" title="七，Arrays"></a>七，Arrays</h3><blockquote><p>此类包含用来操作数组的各种方法。</p><p>注：</p><ol><li>Arrays中的构造函数是私有的，不能创建它的对象</li><li>Arrays中的方法都是静态的</li></ol><p>常用方法：</p><ol><li><p>toString(Object[] arr)：将数组以字符串的形式返回</p></li><li><p>binarySearch(Object[] arr，Object key)：使用二分搜索法查找指定元素在数组中的下标</p><p>前提：</p><ol><li>升序排列 </li><li>元素唯一</li></ol></li><li><p>copyOf(Object[] arr，int length)：根据指定的长度创建新数组，将arr数组中的元素拷贝新数组中</p></li><li><p>copyOfRange(Object[] arr，int from，int to)：根据下标范围拷贝到新创建的数组中</p></li><li><p>fill(Object[] arr，Object value)：将value值赋值给数组中的每一个元素</p></li></ol></blockquote><blockquote><p>sort(Object[] arr)：根据元素的自然顺序对指定对象数组按升序进行排序。</p><p>通过sort()方法对对象的属性进行排序：</p><p>方式一的步骤：</p><ol><li>实现 Comparable 接口</li><li>重写 compareTo 方法</li><li>在 compareTo 方法中返回要比较的属性的差值，<ol><li>升序：<code>this.属性-参数.属性</code>，</li><li>降序：<code>参数.属性-this.属性</code></li></ol></li></ol><p>方式二：调用sort()方法的重载形式sort(Object[] arr，Comparator c)</p><ol><li><p>调用sort(Object[] arr，Comparator c)，传入要排序的数组和 Comparator 的实现类对象</p></li><li><p>重写 Comparator 的 compare(T t1，T t2)方法</p></li><li><p>在compare方法中返回t1和t2的属性差值</p><ol><li>升序：<code>t1.属性 - t2.属性</code></li><li>降序：<code>t2.属性 - t1.属性</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(emps,<span class="keyword">new</span> Comparator&lt;Emp&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Emp o1, Emp o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.salary - o1.salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="八，Object"><a href="#八，Object" class="headerlink" title="八，Object"></a>八，Object</h3><blockquote><p>概念：类 <code>Object</code> 是类层次结构的根类。每个类都使用 <code>Object</code> 作为超类。</p><p>常用方法：</p><ol><li><p>toString()</p><p>打印对象时，会默认调用toString()方法，如果没有重写Object中的toString()，会执行Object中的toString()，输出地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以对Object中的toString()进行重写，来更方便直观的查看对象的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Teacher&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">        <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li><p>equals</p><p>用于比较两个对象的地址值是否相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过重写equals()方法来比较两个对象的属性是否完全相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(obj != <span class="keyword">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Emp)&#123;</span><br><span class="line">        Emp e = (Emp)obj;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.name != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(e.name) &amp;&amp; <span class="keyword">this</span>.age == e.age;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(e.name == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.age == e.age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || <span class="keyword">this</span>.getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Stu stu = (Stu) o;</span><br><span class="line">    <span class="keyword">return</span> age == stu.age &amp;&amp;</span><br><span class="line">        Objects.equals(name, stu.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>补充：</p><p>Objects 的 equals() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：比较两个对象是否相同，避免了空指针异常</p></blockquote><h3 id="九，String"><a href="#九，String" class="headerlink" title="九，String"></a>九，String</h3><blockquote><p><code>String</code> 类代表字符串。Java 程序中的所有字符串字面值（如 <code>&quot;abc&quot;</code>  ）都作为此类的实例。 </p><p>字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。</p><p>注：</p><ol><li>所有字符串字面值都是String类的对象</li><li>字符串都是常量</li><li>字符串存储在字符串常量池中，是共享的</li><li>== 在比较基本数据类型时，比较的是数据值；== 在比较引用数据类型时，比较的是对象的地址值；比较字符串中的内容是否相同应该是使用 <code>equals()</code></li></ol></blockquote><blockquote><p>构造函数：</p><ol><li>new String()：创建一个空的字符串</li><li>new String(byte[] bytes)：将字节数组中的元素根据ASCII码表转换成字符后生成字符串</li><li>new String(char[] chars)：将字符数组中的元素拼接成一个字符串</li><li>new String(String s)</li><li>new String(byte[] bytes, String charset)：可以根据指定的字符集编码生成字节数组所对应的字符串</li><li>new String(byte[] bytes , int offset , int length)：从字节数组的指定位置开始获取指定数量的元素拼接成字符串</li><li>new String(char[] chars , int offset , int count)：从字符数组的指定位置开始获取指定数量的元素拼接成字符串</li></ol></blockquote><blockquote><p>常用方法：</p><ol><li>charAt(int index)：根据下标返回字符</li><li>indexOf(String str)：根据字符串内容返回所在下标</li><li>indexOf(String str，int index)：从指定位置开始查找指定字符串所在的下标</li><li>lastIndexOf(String str)：返回最后一个字符串内容所在的下标</li><li>lastIndexOf(String str, int index)：从指定位置开始，从后往前查找最后一个字符串所在的下标</li><li>compareTo(String str)：根据字典顺序比较字符的大小，返回差值</li><li>compareToIgnoreCase(String str)：忽略大小写比较</li><li>equals(String str)：比较字符串的内容，返回布尔值</li><li>equalsIgnoreCase(String str)：忽略大小写比较字符串内容</li><li>contains(String str)：判断字符串是否包含子串</li><li>codePointAt(int index)：通过下标返回字符的十进制数</li><li>concat(String str)：拼接字符串</li><li>endsWith(String str)：判断是否以指定字符串结尾</li><li>startsWith(String str)：判断是否以指定字符串开头</li><li>getBytes()：获取字符串的字节数组</li><li>toCharArray()：获取字符串的字符数组</li><li>isEmpty()：判断字符串的内容是否为空</li><li>length()：返回字符串的长度</li><li>replace(String oldStr, String newStr)：将新字符串替换原始字符串</li><li>substring(int index)：从指定位置截取到字符串末尾</li><li>subString(int beginIndex, int endIndex)：从begin下标截取到end下标，不包含end</li><li>toLowerCase()：将大写字母转换成小写字母</li><li>toUpperCase()：将小写字母转换成大写字母</li><li>trim()：去除字符串两端的空格</li></ol></blockquote><blockquote><p>正则表达式</p><p>概念：又称规则表达式，（英语：Regular Expression，在代码中常简写为regex、regexp或RE），它用来对字符串进行匹配、替换、切割、查找。</p><p>特点：</p><ol><li>灵活、逻辑性强</li><li>可以迅速地用非常简单的方式来对字符串进行复杂控制</li><li>对刚学的人来说，可读性差</li></ol><p>功能：</p><ol><li><p>匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(String email)</span></span>&#123;</span><br><span class="line">    String regex = <span class="string">&quot;\\w&#123;6,16&#125;@[0-9a-zA-Z]&#123;2,8&#125;[.]com&quot;</span>;</span><br><span class="line">    System.out.println(email.matches(regex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>切割</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String ip = <span class="string">&quot;192-+-+-+-+-168++++1+++1&quot;</span>;</span><br><span class="line">    String[] strs = ip.split(<span class="string">&quot;[+-]+&quot;</span>);</span><br><span class="line">    System.out.println(Arrays.toString(strs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;你骑过马马马马吗？我骑过马马马马马呀！&quot;</span>;</span><br><span class="line">    String regex = <span class="string">&quot;马+&quot;</span>;</span><br><span class="line">    str = str.replaceAll(regex,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叠词替换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;我我我我我我爱爱爱爱爱爱学习习习习习习习习习习习习&quot;</span>;   <span class="comment">// 我爱学习</span></span><br><span class="line">    String regex = <span class="string">&quot;(.)\\1+&quot;</span>;</span><br><span class="line">    str = str.replaceAll(regex,<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String msg = <span class="string">&quot;today is a funny day,let us go out and play&quot;</span>;</span><br><span class="line">    Pattern p = Pattern.compile(<span class="string">&quot;\\b[a-z]&#123;5&#125;\\b&quot;</span>);</span><br><span class="line">    Matcher m = p.matcher(msg);</span><br><span class="line">    <span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">        System.out.println(m.group());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="十，StringBuilder-和-StringBuffer"><a href="#十，StringBuilder-和-StringBuffer" class="headerlink" title="十，StringBuilder 和 StringBuffer"></a>十，StringBuilder 和 StringBuffer</h3><h4 id="10-1-StringBuilder-概述"><a href="#10-1-StringBuilder-概述" class="headerlink" title="10.1 StringBuilder 概述"></a>10.1 StringBuilder 概述</h4><blockquote><p>一个可变的字符序列。</p><p>StringBuilder 与 StringBuffer 有兼容的 API，</p><p>StringBuilder 不保证同步，StringBuffer 保证同步。</p><p>建议优先采用 StringBuilder ，因为它比 StringBuffer 要快。</p></blockquote><h4 id="10-2-StringBuffer-概述"><a href="#10-2-StringBuffer-概述" class="headerlink" title="10.2 StringBuffer 概述"></a>10.2 StringBuffer 概述</h4><blockquote><p>线程安全的可变字符序列。</p><p>通过某些方法调用可以改变该序列的长度和内容。 </p></blockquote><h4 id="10-3-构造函数"><a href="#10-3-构造函数" class="headerlink" title="10.3 构造函数"></a>10.3 构造函数</h4><blockquote><p>构造函数：</p><ol><li>StringBuilder()</li><li>StringBuilder(int capacity)</li><li>StringBuilder(String str)</li></ol></blockquote><h4 id="10-4-常用方法"><a href="#10-4-常用方法" class="headerlink" title="10.4 常用方法"></a>10.4 常用方法</h4><blockquote><p>常用方法：</p><ol><li>append(Object obj)</li><li>delete(int start, int end)</li><li>deleteCharAt(int index)</li><li>insert(int index, Object obj)</li><li>reverse()</li><li>setCharAt(int index, Char c)</li></ol></blockquote><h4 id="10-5-StringBuilder-和-StringBuffer-的区别"><a href="#10-5-StringBuilder-和-StringBuffer-的区别" class="headerlink" title="10.5 StringBuilder 和 StringBuffer 的区别"></a>10.5 StringBuilder 和 StringBuffer 的区别</h4><blockquote><ol><li>StringBuffer 保证线程安全的（同步的）</li><li>StringBuilder 速度快，不保证同步</li></ol></blockquote><h4 id="10-6-StringBuilder、StringBuffer-与-String-的转换"><a href="#10-6-StringBuilder、StringBuffer-与-String-的转换" class="headerlink" title="10.6 StringBuilder、StringBuffer 与 String 的转换"></a>10.6 StringBuilder、StringBuffer 与 String 的转换</h4><blockquote><ol><li>StringBuilder、StringBuffer -&gt; String</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用toString()</span></span><br><span class="line">StringBuilder sb1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String s1 = sb1.toString();</span><br><span class="line"><span class="comment">// 使用String的构造函数</span></span><br><span class="line">StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(sb2);</span><br></pre></td></tr></table></figure><ol start="2"><li>String -&gt; StringBuilder、StringBuffer</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用StringBuilder、StringBuffer的构造函数</span></span><br><span class="line">String s3 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">StringBuilder sb3 = <span class="keyword">new</span> StringBuilder(s3);</span><br><span class="line">StringBuffer sb4 = <span class="keyword">new</span> StringBuffer(s3);</span><br></pre></td></tr></table></figure></blockquote><h3 id="十一，包装类"><a href="#十一，包装类" class="headerlink" title="十一，包装类"></a>十一，包装类</h3><h4 id="11-1-概念"><a href="#11-1-概念" class="headerlink" title="11.1 概念"></a>11.1 概念</h4><blockquote><p>概念：java 中的数据类型分为基本数据类型和引用数据类型，但是基本数据类型没有对象的概念，不能调用属性和方法，如果我们想要使用基本数据类型的属性和方法，就需要使用基本数据类型所对应的引用数据类型，就是包装类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基本类型                      包装类</span><br><span class="line"><span class="keyword">byte</span>                        Byte</span><br><span class="line"><span class="keyword">short</span>                       Short</span><br><span class="line"><span class="keyword">int</span>                         Integer</span><br><span class="line"><span class="keyword">long</span>                        Long</span><br><span class="line"><span class="keyword">float</span>                       Float</span><br><span class="line"><span class="keyword">double</span>                      Double</span><br><span class="line"><span class="keyword">char</span>                        Character</span><br><span class="line"><span class="keyword">boolean</span>                     Boolean</span><br></pre></td></tr></table></figure><p>补：建议将对象属性的类型写成包装类，不要使用基本类型</p></blockquote><h4 id="11-2-包装类对象的创建"><a href="#11-2-包装类对象的创建" class="headerlink" title="11.2 包装类对象的创建"></a>11.2 包装类对象的创建</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="string">&quot;666&quot;</span>);</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>如果参数不是整数或者不是整数形式的字符串会发生 <code>NumberFormatException</code></li><li>Boolean d = new Boolean(“110+1”); 参数是字符串时，只要参数不是”true”，结果都是 false</li></ol></blockquote><h4 id="11-3-成员方法"><a href="#11-3-成员方法" class="headerlink" title="11.3 成员方法"></a>11.3 成员方法</h4><blockquote><ol><li>toString()：转换成字符串</li><li>doubleValue()：转换成Double类型</li><li>equals()：判断两个值是否相同，前提是数据类型必须是相同的</li><li>compareTo()：比较调用者和参数的大小，返回 1 表示调用者大，-1 表示调用者小，0 表示两者相同</li></ol></blockquote><h4 id="11-4-静态方法和静态变量"><a href="#11-4-静态方法和静态变量" class="headerlink" title="11.4 静态方法和静态变量"></a>11.4 静态方法和静态变量</h4><blockquote><ol><li>MAX_VALUE</li><li>MIN_VALUE</li><li>max(int x，int y)</li><li>min(int x，int y)</li><li>compare(int x，int y)</li><li>sum(int x，int y)</li><li>toBinaryString(int n)</li><li>toOctalString(int n)</li><li>toHexString(int n)</li></ol></blockquote><h4 id="11-5-装箱和拆箱"><a href="#11-5-装箱和拆箱" class="headerlink" title="11.5 装箱和拆箱"></a>11.5 装箱和拆箱</h4><blockquote><p>概念：基本类型与对应包装类之间的转换就是装箱和拆箱</p><p>装箱：将基本类型转换成对应的包装类（基本 -&gt; 包装）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(i);<span class="comment">// 构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">2</span>;</span><br><span class="line">Integer n = Integer.valueOf(m);<span class="comment">// 静态方法</span></span><br></pre></td></tr></table></figure><p>拆箱：将包装类转换成对应的基本类型（包装 -&gt; 基本）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> b = a.intValue();</span><br></pre></td></tr></table></figure><p>从 java5 开始提供了自动装拆箱（直接赋值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动装箱</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">Integer i = a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> b = i;</span><br></pre></td></tr></table></figure><p>注：从 Java9 开始包装类中的构造函数变成了过期函数，建议使用自动装箱来完成创建动作</p></blockquote><h4 id="11-6-基本类型-包装类与字符串的转换"><a href="#11-6-基本类型-包装类与字符串的转换" class="headerlink" title="11.6 基本类型/包装类与字符串的转换"></a>11.6 基本类型/包装类与字符串的转换</h4><blockquote><p>基本类型/包装类 - &gt; 字符串</p><ol><li><p>拼接空字符串</p></li><li><p>使用包装类的静态方法 toString(int n)</p><p>补充：toString(int n，int radix)</p><p>例如：toString(4，2) 表示返回十进制数的二进制数</p></li><li><p>使用包装类的成员方法 toString()</p></li><li><p>使用 String 类中的静态方法 valueOf(int n)</p></li></ol><p>字符串 -&gt; 基本类型/包装类</p><ol><li>使用包装类的构造函数</li><li>使用包装类的静态方法 parseInt(String s)</li><li>使用包装类的静态方法 valueOf(String s)</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一，Scanner&quot;&gt;&lt;a href=&quot;#一，Scanner&quot; class=&quot;headerlink&quot; title=&quot;一，Scanner&quot;&gt;&lt;/a&gt;一，Scanner&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Scanner 是一个专门用于接收键盘输入的类，它在 java.util 包中&lt;/p&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Scanner(System.in)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;常用方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;next()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;nextLine()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;nextInt()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;nextInt(int radix)&lt;/p&gt;
&lt;p&gt;例如：nextInt(2)，表示系统将输入的内容视为二进制数，返回一个对应的十进制数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;nextDouble()&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：如果输入内容的类型与指定类型不匹配会发生 &lt;code&gt;InputMismatchException&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二，Random&quot;&gt;&lt;a href=&quot;#二，Random&quot; class=&quot;headerlink&quot; title=&quot;二，Random&quot;&gt;&lt;/a&gt;二，Random&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Random 是一个专门用于产生随机数的类，它在 java.util 包中&lt;/p&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Random()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;常用方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;nextInt()：随机整个 int 范围内的数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;nextDouble：随机 [0.0，1.0)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;nextInt(int bound)：随机 [0，bound)&lt;/p&gt;
&lt;p&gt;例如：随机 [44，55] ，nextInt(55-44+1)+44&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三，Math&quot;&gt;&lt;a href=&quot;#三，Math&quot; class=&quot;headerlink&quot; title=&quot;三，Math&quot;&gt;&lt;/a&gt;三，Math&lt;/h3&gt;</summary>
    
    
    
    <category term="后端编程" scheme="https://sweeneyzhou.top/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JAVA" scheme="https://sweeneyzhou.top/tags/JAVA/"/>
    
    <category term="学习笔记" scheme="https://sweeneyzhou.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础" scheme="https://sweeneyzhou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="常用类" scheme="https://sweeneyzhou.top/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
    <category term="Scanner" scheme="https://sweeneyzhou.top/tags/Scanner/"/>
    
    <category term="Random" scheme="https://sweeneyzhou.top/tags/Random/"/>
    
    <category term="Math" scheme="https://sweeneyzhou.top/tags/Math/"/>
    
    <category term="Date" scheme="https://sweeneyzhou.top/tags/Date/"/>
    
    <category term="Dateformat" scheme="https://sweeneyzhou.top/tags/Dateformat/"/>
    
    <category term="Calendar" scheme="https://sweeneyzhou.top/tags/Calendar/"/>
    
    <category term="Arrays" scheme="https://sweeneyzhou.top/tags/Arrays/"/>
    
    <category term="Objects" scheme="https://sweeneyzhou.top/tags/Objects/"/>
    
    <category term="String类" scheme="https://sweeneyzhou.top/tags/String%E7%B1%BB/"/>
    
    <category term="StringBuilder" scheme="https://sweeneyzhou.top/tags/StringBuilder/"/>
    
    <category term="StringBuffer" scheme="https://sweeneyzhou.top/tags/StringBuffer/"/>
    
    <category term="包装类" scheme="https://sweeneyzhou.top/tags/%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    
    <category term="装箱拆箱" scheme="https://sweeneyzhou.top/tags/%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/"/>
    
  </entry>
  
  <entry>
    <title>范围修饰符、代码块、内部类</title>
    <link href="https://sweeneyzhou.top/%E8%8C%83%E5%9B%B4%E4%BF%AE%E9%A5%B0%E7%AC%A6%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB.html"/>
    <id>https://sweeneyzhou.top/%E8%8C%83%E5%9B%B4%E4%BF%AE%E9%A5%B0%E7%AC%A6%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB.html</id>
    <published>2021-04-21T01:01:41.832Z</published>
    <updated>2021-04-21T01:17:59.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一，范围修饰符"><a href="#一，范围修饰符" class="headerlink" title="一，范围修饰符"></a>一，范围修饰符</h3><blockquote><p>概念：也叫权限修饰符，修饰成员在代码中的可见性</p><p>分类：</p><ol><li>public：公共的</li><li>protected：受保护的</li><li>[default]：默认</li><li>private：私有的</li></ol><p>范围修饰符只能修饰成员</p></blockquote><blockquote><p><code>public &gt; protected &gt; [default] &gt; private</code></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        public          protected            [default]                private</span><br><span class="line">本类中              √                √                  √                       √</span><br><span class="line">同包的其他类中        √                √                  √                       ×</span><br><span class="line">其他包的子类中        √                √                  ×                        ×</span><br><span class="line">其他包的其他类        √                 ×                  ×                        ×</span><br></pre></td></tr></table></figure><p>public：任何位置都能访问</p><p>private：只有本类中可以访问</p><p>protected：同包中可以访问，子类可以访问（只有其他包中的无关类不能访问）</p><p>[default]：只能在同包中访问</p></blockquote><h3 id="二，代码块"><a href="#二，代码块" class="headerlink" title="二，代码块"></a>二，代码块</h3><h4 id="2-1-概念和分类"><a href="#2-1-概念和分类" class="headerlink" title="2.1 概念和分类"></a>2.1 概念和分类</h4><blockquote><p>概念：</p><p>使用一对大括号括起来的代码段就是一个代码块</p><p>分类：</p><ol><li>普通代码块</li><li>静态代码块</li><li>构造代码块</li><li>同步代码块 synchronized</li></ol></blockquote><h4 id="2-2-普通代码块"><a href="#2-2-普通代码块" class="headerlink" title="2.2 普通代码块"></a>2.2 普通代码块</h4><blockquote><p>定义在局部位置的代码块</p><p>注：变量只有在定义它的代码块中才可以使用，代码块结束后，代码块中定义的变量就被释放</p></blockquote><h4 id="2-3-静态代码块"><a href="#2-3-静态代码块" class="headerlink" title="2.3 静态代码块"></a>2.3 静态代码块</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span>&#123;</span><br><span class="line">     <span class="comment">// 静态代码块中的语句</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>静态代码块最优先执行</li><li>静态代码块只执行一次</li></ol><p>作用：</p><ol><li>读取配置文件</li><li>对静态属性进行初始化</li></ol><p>注：多个静态代码块会根据书写顺序从上到下依次执行</p></blockquote><h4 id="2-4-构造代码块"><a href="#2-4-构造代码块" class="headerlink" title="2.4 构造代码块"></a>2.4 构造代码块</h4><blockquote><p>概念：定义在成员位置上，没有任何修饰符的代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 构造代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>优先于构造函数执行，晚于静态代码块</li><li>每次创建对象都会执行</li></ol><p>注：对属性进行初始化</p></blockquote><h3 id="三，内部类"><a href="#三，内部类" class="headerlink" title="三，内部类"></a>三，内部类</h3><h4 id="3-1-概念的和分类"><a href="#3-1-概念的和分类" class="headerlink" title="3.1 概念的和分类"></a>3.1 概念的和分类</h4><blockquote><p>概念：定义在其他类中的类</p><p>分类：</p><ol><li>成员内部类</li><li>静态内部类</li><li>局部内部类</li><li>匿名内部类</li></ol></blockquote><h4 id="3-2-成员内部类"><a href="#3-2-成员内部类" class="headerlink" title="3.2 成员内部类"></a>3.2 成员内部类</h4><blockquote><p>概念：定义在其他类的成员位置上的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li><p>内部类可以直接访问外部类中的所有成员（包括私有的）</p></li><li><p>外部类访问内部类的成员需要在外部类中创建内部类的对象进行访问</p></li><li><p>其他类创建内部类的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类 对象名 = <span class="keyword">new</span> 外部类().new 内部类();</span><br></pre></td></tr></table></figure></li><li><p>内部类和外部类出现同名变量、方法时，内部类访问外部类，可以通过</p><ol><li><p>创建外部类对象</p></li><li><p>```java<br>外部类.this.成员名</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#### 3.3 静态内部类</span></span><br><span class="line"></span><br><span class="line">概念：静态的成员内部类</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>注：</p><ol><li><p>静态内部类只能访问外部类中的静态成员，外部类中的非静态成员只能在内部类中创建对象访问</p></li><li><p>外部类访问静态内部类中的的成员，必须在外部类中创建内部类的对象访问</p></li><li><p>其他类访问静态内部类中的静态成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.静态内部类.静态成员</span><br></pre></td></tr></table></figure></li><li><p>其他类创建静态内部类的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类 对象名 = <span class="keyword">new</span> 外部类.内部类();</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="3-4-局部内部类"><a href="#3-4-局部内部类" class="headerlink" title="3.4 局部内部类"></a>3.4 局部内部类</h4><blockquote><p>概念：将一个类定义在其他类的方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>局部内部类可以直接访问外部类中的成员（包括私有的）</li><li>外部类访问内部类的成员，只能在定义局部内部类的方法中创建这个局部内部类的对象进行调用</li><li>其他类访问局部内部类的成员，只能在其他类中创建外部类的对象，使用外部类的对象调用定义了这个局部内部类的方法</li></ol></blockquote><h4 id="3-5-匿名内部类"><a href="#3-5-匿名内部类" class="headerlink" title="3.5 匿名内部类"></a>3.5 匿名内部类</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名/接口名()&#123;</span><br><span class="line">    <span class="comment">// 重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作用：创建子类/实现类的对象</p><p>注：使用匿名内部类创建子类对象，无法再调用子类的特有内容</p></blockquote><h4 id="3-6-补充"><a href="#3-6-补充" class="headerlink" title="3.6 补充"></a>3.6 补充</h4><blockquote><ol><li><p>成员内部类和静态内部类编译后的文件名：外部类$内部类.class</p></li><li><p>局部内部类编译后的文件名：外部类$序号内部类.class</p><p>序号从1开始，根据局部内部类所在方法的调用顺序排序</p></li><li><p>匿名内部类编译后的文件名：其他类$序号.class</p></li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一，范围修饰符&quot;&gt;&lt;a href=&quot;#一，范围修饰符&quot; class=&quot;headerlink&quot; title=&quot;一，范围修饰符&quot;&gt;&lt;/a&gt;一，范围修饰符&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;概念：也叫权限修饰符，修饰成员在代码中的可见性&lt;/p&gt;
&lt;p&gt;分类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;public：公共的&lt;/li&gt;
&lt;li&gt;protected：受保护的&lt;/li&gt;
&lt;li&gt;[default]：默认&lt;/li&gt;
&lt;li&gt;private：私有的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;范围修饰符只能修饰成员&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;public &amp;gt; protected &amp;gt; [default] &amp;gt; private&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight txt&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;		        public          protected            [default]                private&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;本类中              √                √                  √                       √&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;同包的其他类中        √                √                  √                       ×&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其他包的子类中        √                √                  ×                        ×&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其他包的其他类        √                 ×                  ×                        ×&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;public：任何位置都能访问&lt;/p&gt;
&lt;p&gt;private：只有本类中可以访问&lt;/p&gt;
&lt;p&gt;protected：同包中可以访问，子类可以访问（只有其他包中的无关类不能访问）&lt;/p&gt;
&lt;p&gt;[default]：只能在同包中访问&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二，代码块&quot;&gt;&lt;a href=&quot;#二，代码块&quot; class=&quot;headerlink&quot; title=&quot;二，代码块&quot;&gt;&lt;/a&gt;二，代码块&lt;/h3&gt;&lt;h4 id=&quot;2-1-概念和分类&quot;&gt;&lt;a href=&quot;#2-1-概念和分类&quot; class=&quot;headerlink&quot; title=&quot;2.1 概念和分类&quot;&gt;&lt;/a&gt;2.1 概念和分类&lt;/h4&gt;</summary>
    
    
    
    <category term="后端编程" scheme="https://sweeneyzhou.top/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JAVA" scheme="https://sweeneyzhou.top/tags/JAVA/"/>
    
    <category term="学习笔记" scheme="https://sweeneyzhou.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础" scheme="https://sweeneyzhou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="范围修饰符" scheme="https://sweeneyzhou.top/tags/%E8%8C%83%E5%9B%B4%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    
    <category term="代码块" scheme="https://sweeneyzhou.top/tags/%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
    <category term="静态代码块" scheme="https://sweeneyzhou.top/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
    <category term="构造代码块" scheme="https://sweeneyzhou.top/tags/%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
    <category term="内部类" scheme="https://sweeneyzhou.top/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
    <category term="成员内部类" scheme="https://sweeneyzhou.top/tags/%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
    <category term="静态内部类" scheme="https://sweeneyzhou.top/tags/%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
    <category term="局部内部类" scheme="https://sweeneyzhou.top/tags/%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
    <category term="匿名内部类" scheme="https://sweeneyzhou.top/tags/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java的三大特性：封装、继承、多态</title>
    <link href="https://sweeneyzhou.top/%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81.html"/>
    <id>https://sweeneyzhou.top/%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81.html</id>
    <published>2021-04-21T01:01:41.810Z</published>
    <updated>2021-04-21T01:18:18.057Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一，封装"><a href="#一，封装" class="headerlink" title="一，封装"></a>一，封装</h3><blockquote><p>面向三大特性：封装、继承、多态</p></blockquote><h4 id="1-1-封装的概念"><a href="#1-1-封装的概念" class="headerlink" title="1.1 封装的概念"></a>1.1 封装的概念</h4><blockquote><p>生活中的封装：打包、机箱</p><p>代码中的封装：方法、类、包</p></blockquote><h4 id="1-2-封装的好处"><a href="#1-2-封装的好处" class="headerlink" title="1.2 封装的好处"></a>1.2 封装的好处</h4><blockquote><ol><li>提高了代码的安全性</li><li>提高了代码的复用性</li><li>隐藏了实现的细节</li></ol></blockquote><h4 id="1-3-属性的封装"><a href="#1-3-属性的封装" class="headerlink" title="1.3 属性的封装"></a>1.3 属性的封装</h4><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我叫&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;，今年&quot;</span>+<span class="keyword">this</span>.age+<span class="string">&quot;岁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        s.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        s.age = <span class="number">420</span>;</span><br><span class="line">        s.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中对age的赋值出现了不合法的数据，所以调用show()方法出现的结果也是不正常的。</p><p>出现上述情况的原因：</p><ol><li>属性可以通过对象任意调用</li><li>对属性值没有进行合理性判断</li></ol><p>解决办法：</p><ol><li>通过对属性进行私有化的封装来限制属性的调用</li><li>需要对属性进行合理性的判断</li></ol></blockquote><blockquote><ol><li><p>通过对属性进行私有化的封装来限制属性的调用</p><p>使用关键字<code>private</code>修饰属性，<code>private</code>表示私有的，被<code>private</code>修饰的成员，只能在本类中使用</p></li><li><p>需要对属性进行合理性的判断</p><p>set方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;set中的&quot;</span>+<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span>(age &gt;= <span class="number">0</span> &amp;&amp; age &lt;= <span class="number">150</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;get中的&quot;</span>+<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注：如果属性是boolean类型的，那么get方法的方法名会变成isXxx()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">boolean</span> sex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>一个标准的实体类（JavaBean）必须包含：</p><ol><li>私有化的属性</li><li>对外提供属性的set/get方法</li><li>空参的构造函数</li></ol></blockquote><h3 id="二，继承"><a href="#二，继承" class="headerlink" title="二，继承"></a>二，继承</h3><h4 id="2-1-继承的概念"><a href="#2-1-继承的概念" class="headerlink" title="2.1 继承的概念"></a>2.1 继承的概念</h4><blockquote><p>生活中的继承：子女拥有父母的东西</p><p>代码中的继承：指的是类与类之间产生了关系，多个类中的共性内容进行了向上抽取</p></blockquote><blockquote><p>父类：超类、基类 superclass</p><p>​        父类的范围往往比较大，而属性和方法一般都比较少</p><p>子类：派生类、衍生类 subclass</p><p>​         子类的范围往往更小，而属性和方法一般更多</p></blockquote><blockquote><p>注：</p><ol><li>所有类都直接或者间接的继承了<code>Object类</code></li><li>一般子类名字的后缀是父类的名字</li><li>子类除了继承了父类的共性内容以外，还可以有自己的特有内容</li></ol></blockquote><h4 id="2-2-继承的好处"><a href="#2-2-继承的好处" class="headerlink" title="2.2 继承的好处"></a>2.2 继承的好处</h4><blockquote><ol><li>提供了代码的复用性，子类可以直接访问父类中非私有的成员    </li><li>为多态提供了前提，<code>一个子类就是一个父类</code></li></ol></blockquote><h4 id="2-3-子类父类的继承关系"><a href="#2-3-子类父类的继承关系" class="headerlink" title="2.3 子类父类的继承关系"></a>2.3 子类父类的继承关系</h4><blockquote><p>​    关键字：<code>extends</code></p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类</span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String brand;</span><br><span class="line">    <span class="keyword">public</span> String color;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> price;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>注：</p><ol><li>一个父类可以有多个子类（多个子类可以继承同一个父类）</li><li>一个类不能同时继承多个父类</li><li>可以有多层继承（继承具有传递性）</li></ol></blockquote><h4 id="2-4-子类父类中同名成员的问题"><a href="#2-4-子类父类中同名成员的问题" class="headerlink" title="2.4 子类父类中同名成员的问题"></a>2.4 子类父类中同名成员的问题</h4><h5 id="2-4-1-同名变量"><a href="#2-4-1-同名变量" class="headerlink" title="2.4.1 同名变量"></a>2.4.1 同名变量</h5><blockquote><p>当子父类中出现同名变量时，会根据“就近原则”，优先访问子类中的成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">6</span>;</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.i);<span class="comment">//4 访问父类中的同名变量i</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.i);<span class="comment">//5 访问本类中的同名变量i</span></span><br><span class="line">        System.out.println(i);<span class="comment">//6 访问局部变量i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h5 id="2-4-2-同名方法"><a href="#2-4-2-同名方法" class="headerlink" title="2.4.2 同名方法"></a>2.4.2 同名方法</h5><blockquote><p>当子父类中出现同名方法时，会根据“就近原则”，优先访问子类中的成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        f();<span class="comment">// 调用f()本质上是this.f()，是使用本类中的对象调用本类中的f方法</span></span><br><span class="line">        <span class="keyword">super</span>.f();<span class="comment">// 调用父类中的同名f方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>重写：</p><p>在继承关系中，子类对父类的功能进行扩展就是方法的重写</p><p>重写的格式要求：</p><ol><li><p>方法名相同</p></li><li><p>参数列表相同</p></li><li><p>子类方法的范围修饰符必须大于等于父类的</p><p><code>public &gt; protected &gt; [defalut] &gt;  private</code></p></li><li><p>子类方法的返回类型必须是父类方法的返回类型，或者是父类方法返回类型的子类</p></li></ol><p>注：@Override 重写的注解，可以用来校验当前是否满足重写规则</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送了：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 注解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.sendMsg(msg);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送了：&quot;</span>+<span class="string">&quot;^.-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-5-父类属性私有化的问题"><a href="#2-5-父类属性私有化的问题" class="headerlink" title="2.5 父类属性私有化的问题"></a>2.5 父类属性私有化的问题</h4><blockquote><p>问题：父类中有子类的共性属性，这些在父类中应该使用private进行私有化封装，但是一旦私有化了对子类就是不可见的，子类无法访问父类中的这些私有的共性属性，如何在子类中访问到这些私有属性？</p><p>解决办法：</p><p>方式一：</p><p>父类中的属性私有化了，但是会对外提供访问这些属性的set/get方法，set/get方法是公共的，所以可以通过父类的set/get方法来访问</p><p>方式二：</p><p>重载父类和子类的构造函数，在子类的构造函数中通过<code>super(参数列表)</code>调用父类的构造函数来对子类对象的属性进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String nickname,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nickname,age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String nickname,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// set/get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>对子类特有属性的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span></span>&#123;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String name, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name;</span><br><span class="line">     <span class="keyword">this</span>.salary = salary;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// set/get方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">extends</span> <span class="title">Emp</span></span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">double</span> jiangJin;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Programmer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Programmer</span><span class="params">(String name, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>(name, salary);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Programmer</span><span class="params">(String name, <span class="keyword">double</span> salary,<span class="keyword">double</span> jiangJin)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>(name, salary);</span><br><span class="line">     <span class="keyword">this</span>.jiangJin = jiangJin;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// set/get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-6-继承关系中的构造函数问题"><a href="#2-6-继承关系中的构造函数问题" class="headerlink" title="2.6 继承关系中的构造函数问题"></a>2.6 继承关系中的构造函数问题</h4><blockquote><ol><li>任何一个类的任何一个构造函数中都调用父类的默认构造函数</li><li>父类构造函数的调用必须在子类构造函数的第一行</li></ol></blockquote><h4 id="2-7-super-和-this"><a href="#2-7-super-和-this" class="headerlink" title="2.7 super 和 this"></a>2.7 super 和 this</h4><blockquote><p>super表示当前类的父类对象</p><p>作用：</p><ol><li>调用父类的属性、方法</li><li>调用父类的构造函数<ol><li>任何一个类的任何一个构造函数中都调用父类的默认构造函数</li><li>子类的重载构造函数中可以通过父类的重载构造函数对子类属性初始化</li></ol></li></ol></blockquote><blockquote><p>this表示当前类的对象，在方法中this表示当前方法的调用者</p><p>作用：</p><ol><li><p>调用本类的属性、方法</p></li><li><p>调用本类中的其他构造方法<code>this(参数列表)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 健康状态</span></span><br><span class="line">    String health;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">(String name,<span class="keyword">int</span> age,String health)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name,age);</span><br><span class="line">        <span class="keyword">this</span>.health = health;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>注：</p><ol><li>构造函数的调用只能在构造函数中</li><li>构造函数的调用必须是第一条语句</li><li>如果本类中的构造函数中调用了本类的其他构造函数，那么就不再调用父类的构造函数了</li></ol></blockquote><h4 id="2-8-final"><a href="#2-8-final" class="headerlink" title="2.8 final"></a>2.8 final</h4><blockquote><p>final可以修饰：</p><ol><li><p>变量、对象：创建后不能再被赋值</p><p>注：成员变量被final修饰后，必须手动赋值初始化</p></li><li><p>类：最终类，不能被继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法：不能被重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(String s)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="三，抽象类"><a href="#三，抽象类" class="headerlink" title="三，抽象类"></a>三，抽象类</h3><h4 id="3-1-抽象方法和抽象类的概念"><a href="#3-1-抽象方法和抽象类的概念" class="headerlink" title="3.1 抽象方法和抽象类的概念"></a>3.1 抽象方法和抽象类的概念</h4><blockquote><p>概念：当子类的共性方法抽取到父类中，而父类无法描述每个子类的具体实现时，这种方法就是抽象的。</p><p>抽象方法必须在抽象类中</p><p>关键字：<code>abstract</code></p><p>抽象方法和抽象类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getS</span><span class="params">(<span class="keyword">double</span> r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-2-抽象类的使用"><a href="#3-2-抽象类的使用" class="headerlink" title="3.2 抽象类的使用"></a>3.2 抽象类的使用</h4><blockquote><p>步骤：</p><ol><li><p>创建子类继承抽象类</p></li><li><p>重写抽象类中的所有抽象方法</p><p>注：如果一个类继承了抽象类，要么重写它的所有抽象方法，要么这个类也是一个抽象类</p></li><li><p>创建子类对象调用方法</p></li></ol></blockquote><h4 id="3-3-注意事项"><a href="#3-3-注意事项" class="headerlink" title="3.3 注意事项"></a>3.3 注意事项</h4><blockquote><ol><li>抽象类不能被实例化（不能创建抽象类的对象，不能new）</li><li>抽象类一定是一个父类，因为抽象类是子类的共性内容抽取而来的</li><li>抽象方法一定在抽象类中</li><li>抽象类中既可以抽象方法，也可以有非抽象方法，也可以没有抽象方法</li><li>不能与abstract关键字一起使用的关键字：final、static、private</li><li>抽象类中可以有构造方法</li></ol></blockquote><h4 id="3-4-匿名对象"><a href="#3-4-匿名对象" class="headerlink" title="3.4 匿名对象"></a>3.4 匿名对象</h4><blockquote><p>概念：创建对象时不指定对象名（引用变量名）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>好处：书写简便</p><p>弊端：</p><ol><li>只能使用一次</li><li>可读性差</li></ol></blockquote><h4 id="3-5-匿名创建子类对象（匿名内部类）"><a href="#3-5-匿名创建子类对象（匿名内部类）" class="headerlink" title="3.5 匿名创建子类对象（匿名内部类）"></a>3.5 匿名创建子类对象（匿名内部类）</h4><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Emp()&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;work&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 抽象类&#123;</span><br><span class="line">    <span class="comment">// 方法重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><h3 id="四，接口"><a href="#四，接口" class="headerlink" title="四，接口"></a>四，接口</h3><h4 id="4-1-接口的概念"><a href="#4-1-接口的概念" class="headerlink" title="4.1 接口的概念"></a>4.1 接口的概念</h4><blockquote><p>概念：接口是多个类的公共规则，接口是一种引用数据类型，它的本质是一个类</p><p>作用：</p><ol><li>提供了规范、标准</li><li>对功能进行了扩展</li></ol></blockquote><h4 id="4-2-接口的定义"><a href="#4-2-接口的定义" class="headerlink" title="4.2 接口的定义"></a>4.2 接口的定义</h4><blockquote><p>关键字：<code>interface</code></p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口在编译后生成的仍是<code>.class</code>文件</p></blockquote><h4 id="4-3-接口中成员的特点"><a href="#4-3-接口中成员的特点" class="headerlink" title="4.3 接口中成员的特点"></a>4.3 接口中成员的特点</h4><h5 id="4-3-1-接口中成员变量的特点"><a href="#4-3-1-接口中成员变量的特点" class="headerlink" title="4.3.1 接口中成员变量的特点"></a>4.3.1 接口中成员变量的特点</h5><blockquote><p>接口中的成员变量默认被<code>public static final</code>修饰</p></blockquote><h5 id="4-3-2-接口中成员方法的特点"><a href="#4-3-2-接口中成员方法的特点" class="headerlink" title="4.3.2 接口中成员方法的特点"></a>4.3.2 接口中成员方法的特点</h5><blockquote><p>接口中的成员方法默认被<code>public abstract</code>修饰</p></blockquote><h4 id="4-4-接口的使用"><a href="#4-4-接口的使用" class="headerlink" title="4.4 接口的使用"></a>4.4 接口的使用</h4><blockquote><p>关键字：<code>implements</code></p><p>步骤：</p><ol><li>创建实现类实现接口 </li><li>重写所有抽象方法</li><li>创建实现类对象调用方法</li></ol></blockquote><blockquote><p>接口也可以使用匿名内部类的方式创建实现类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 接口()&#123;</span><br><span class="line">  <span class="comment">// 重写方法  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Usb()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-5-接口的新特性"><a href="#4-5-接口的新特性" class="headerlink" title="4.5 接口的新特性"></a>4.5 接口的新特性</h4><h5 id="4-5-1-接口中的普通（默认）方法"><a href="#4-5-1-接口中的普通（默认）方法" class="headerlink" title="4.5.1 接口中的普通（默认）方法"></a>4.5.1 接口中的普通（默认）方法</h5><blockquote><p>从 Java8 开始，允许在接口中定义普通（默认）方法</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口 </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> 返回类型 方法名(参数列表)&#123;</span><br><span class="line">        方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意义：为了解决接口中功能升级的问题</p><p>注：</p><ol><li><p>接口中的普通（默认）方法也可以重写，重写后一定不能加上<code>default</code></p></li><li><p>如果实现类实现的多个接口中出现了同名同参的普通方法，那么实现类必须重写它，</p><p>此时，如果在实现类中想要调用某个指定接口的普通方法，必须<code>接口名.super.方法名()</code>进行调用</p></li></ol></blockquote><h4 id="4-5-2-接口中的静态方法"><a href="#4-5-2-接口中的静态方法" class="headerlink" title="4.5.2 接口中的静态方法"></a>4.5.2 接口中的静态方法</h4><blockquote><p>从 Java8 开始，允许在接口中定义静态方法</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口 </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> 返回类型 方法名(参数列表)&#123;</span><br><span class="line">        方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>接口中的静态方法的定义和使用与普通类中静态方法的定义和使用相同</li><li>接口中的静态方法只能通过接口名调用，不能通过实现类名或者实现类的对象调用</li></ol></blockquote><h5 id="4-5-3-接口中的私有方法"><a href="#4-5-3-接口中的私有方法" class="headerlink" title="4.5.3 接口中的私有方法"></a>4.5.3 接口中的私有方法</h5><blockquote><p>从 Java9 开始，允许在接口中定义私有方法</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口 </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> 返回类型 方法名(参数列表)&#123;</span><br><span class="line">        方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：目的是为接口中的普通（默认）方法提供不需要对外暴露的功能支持</p></blockquote><h4 id="4-6-类、接口的关系"><a href="#4-6-类、接口的关系" class="headerlink" title="4.6 类、接口的关系"></a>4.6 类、接口的关系</h4><h5 id="4-6-1-类与类的关系"><a href="#4-6-1-类与类的关系" class="headerlink" title="4.6.1 类与类的关系"></a>4.6.1 类与类的关系</h5><blockquote><p>类与类的关系是继承：子类继承父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：类与类之间只存在单继承</p></blockquote><h5 id="4-6-2-类与接口的关系"><a href="#4-6-2-类与接口的关系" class="headerlink" title="4.6.2 类与接口的关系"></a>4.6.2 类与接口的关系</h5><blockquote><p>类与接口的关系是实现：实现类实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 实现类 <span class="keyword">implements</span> 接口<span class="title">A</span>,接口<span class="title">B</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>一个类可以实现多个接口</li><li>实现类必须实现多个接口中的所有抽象方法，如果多个接口中有同名同参的方法，只要实现一次</li><li>接口中的普通（默认）方法与另一个接口中的普通（默认）或者抽象方法同名同参时，实现类必须重写</li></ol></blockquote><h5 id="4-6-3-接口与接口的关系"><a href="#4-6-3-接口与接口的关系" class="headerlink" title="4.6.3 接口与接口的关系"></a>4.6.3 接口与接口的关系</h5><blockquote><p>接口与接口的关系是继承：子接口继承父接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 子接口 <span class="keyword">extends</span> 父接口<span class="title">A</span>,父接口<span class="title">B</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>一个接口可以继承多个接口</li><li>父接口中的普通（默认）方法与另一个父接口中的普通（默认）或者抽象方法同名同参时，子接口必须重写</li></ol></blockquote><h5 id="4-6-4-类在继承类的同时实现接口"><a href="#4-6-4-类在继承类的同时实现接口" class="headerlink" title="4.6.4 类在继承类的同时实现接口"></a>4.6.4 类在继承类的同时实现接口</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 实现类/子类 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 接口<span class="title">A</span>,接口<span class="title">B</span>  </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>父类中的方法与接口中的普通（默认）方法同名同参时，优先调用父类的</li><li>父类中的方法与接口中的抽象方法同名同参时，实现类不需要再重写</li></ol><p><code>以上注意点依据“就近原则”</code></p></blockquote><h4 id="4-7-接口和抽象类的异同"><a href="#4-7-接口和抽象类的异同" class="headerlink" title="4.7 接口和抽象类的异同"></a>4.7 接口和抽象类的异同</h4><blockquote><p>同：</p><ol><li>都不能创建对象</li><li>都可以定义抽象方法</li><li>都需要子类/实现类来继承/实现</li></ol><p>异：</p><ol><li>抽象类被子类继承（extends），接口被实现类实现（implements）</li><li>类与类之间只存在单继承，接口与接口之间可以多继承</li><li>接口中的成员变量都是公共的静态常量，接口中的成员方法都是公共的抽象的</li><li>抽象类中有构造函数，接口中没有构造函数</li><li>抽象类封装的是子类的共性内容，接口是对功能的封装，接口是方法的集合</li></ol><p>抽象类和接口的选用：建议优先使用接口，接口避免了单继承的局限性</p></blockquote><h3 id="五，多态"><a href="#五，多态" class="headerlink" title="五，多态"></a>五，多态</h3><h4 id="5-1-多态的概念"><a href="#5-1-多态的概念" class="headerlink" title="5.1 多态的概念"></a>5.1 多态的概念</h4><blockquote><p>多态的前提是继承或者实现</p><p><code>一个子类就是一个父类</code></p><p>代码中的体现：父类的引用变量指向子类对象（把子类对象赋值给父类的引用变量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">extends</span> <span class="title">Emp</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类 引用变量 = 子类对象;</span></span><br><span class="line">Emp e = <span class="keyword">new</span> Programmer();</span><br></pre></td></tr></table></figure></blockquote><h4 id="5-2-多态下调用成员的特点"><a href="#5-2-多态下调用成员的特点" class="headerlink" title="5.2 多态下调用成员的特点"></a>5.2 多态下调用成员的特点</h4><h5 id="5-2-1-多态下调用成员变量的特点"><a href="#5-2-1-多态下调用成员变量的特点" class="headerlink" title="5.2.1 多态下调用成员变量的特点"></a>5.2.1 多态下调用成员变量的特点</h5><blockquote><p>编译时期：父类中没有这个变量，编译失败；父类中这个变量，编译才通过</p><p>运行时期：访问的是父类中的变量</p><p>简单记忆：编译运行都看左边</p><p>小结：多态下，不能访问子类的特有变量</p></blockquote><h5 id="5-2-2-多态下调用成员方法的特点"><a href="#5-2-2-多态下调用成员方法的特点" class="headerlink" title="5.2.2 多态下调用成员方法的特点"></a>5.2.2 多态下调用成员方法的特点</h5><blockquote><p>编译时期：父类中没有这个方法，编译失败；父类中有这个方法，编译才通过</p><p>运行时期：访问的是子类中的方法</p><p>简单记忆：编译看左边，运行看右边</p><p>小结：多态下，不能访问子类的特有方法</p></blockquote><h4 id="5-3-多态的应用"><a href="#5-3-多态的应用" class="headerlink" title="5.3 多态的应用"></a>5.3 多态的应用</h4><blockquote><p>场景1：使用父类作为方法的形参，调用方法时，实参可以是该父类或者它的任何一个子类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">System.out.println(list);</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">Collections.shuffle(list);<span class="comment">// shuffle方法的形参是List，实参可以传递List的任何一个子类/实现类</span></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;讲课&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nurse</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;护理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Nurse n = <span class="keyword">new</span> Nurse();</span><br><span class="line">        f(n);</span><br><span class="line">        Teacher t = <span class="keyword">new</span> Teacher();</span><br><span class="line">        f(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Human h)</span></span>&#123;</span><br><span class="line">        h.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>场景2：使用父类作为方法的返回类型，此时方法的返回值可以是该父类或者它的任何一个子类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> HardWare <span class="title">build</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Mouse();</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> KeyBoard();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">HardWare</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeyBoard</span> <span class="keyword">extends</span> <span class="title">HardWare</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HardWare</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="5-4-多态的转型"><a href="#5-4-多态的转型" class="headerlink" title="5.4 多态的转型"></a>5.4 多态的转型</h4><h5 id="5-4-1-向上转型"><a href="#5-4-1-向上转型" class="headerlink" title="5.4.1 向上转型"></a>5.4.1 向上转型</h5><blockquote><p>多态的本质就是向上转型，父类的引用变量指向子类对象</p><p>注：多态下也就是向上转型后，无法访问子类的特有内容</p></blockquote><h5 id="5-4-2-向下转型"><a href="#5-4-2-向下转型" class="headerlink" title="5.4.2 向下转型"></a>5.4.2 向下转型</h5><blockquote><p>多态下，无法访问子类的特有内容，必须向下转型</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子类/实现类 变量名 = (子类/实现类)父类的引用变量;</span><br><span class="line"></span><br><span class="line">Human h = <span class="keyword">new</span> Teacher();</span><br><span class="line">Teacher t = (Teacher)h;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>注：在向下转型的过程中，如果强转的目标类型不是多态时指定的类型会发生<code>ClassCastException类型转换异常</code></p><p>解决类型转换异常需要使用关键字<code>instanceof</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象 <span class="keyword">instanceof</span> 类型</span><br></pre></td></tr></table></figure><p>作用：判断该对象是否是该类型的，返回布尔值</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一，封装&quot;&gt;&lt;a href=&quot;#一，封装&quot; class=&quot;headerlink&quot; title=&quot;一，封装&quot;&gt;&lt;/a&gt;一，封装&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;面向三大特性：封装、继承、多态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-1-封装的概念&quot;&gt;&lt;a href=&quot;#1-1-封装的概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 封装的概念&quot;&gt;&lt;/a&gt;1.1 封装的概念&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;生活中的封装：打包、机箱&lt;/p&gt;
&lt;p&gt;代码中的封装：方法、类、包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-2-封装的好处&quot;&gt;&lt;a href=&quot;#1-2-封装的好处&quot; class=&quot;headerlink&quot; title=&quot;1.2 封装的好处&quot;&gt;&lt;/a&gt;1.2 封装的好处&lt;/h4&gt;</summary>
    
    
    
    <category term="后端编程" scheme="https://sweeneyzhou.top/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JAVA" scheme="https://sweeneyzhou.top/tags/JAVA/"/>
    
    <category term="学习笔记" scheme="https://sweeneyzhou.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础" scheme="https://sweeneyzhou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="三大特性" scheme="https://sweeneyzhou.top/tags/%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    
    <category term="封装" scheme="https://sweeneyzhou.top/tags/%E5%B0%81%E8%A3%85/"/>
    
    <category term="继承" scheme="https://sweeneyzhou.top/tags/%E7%BB%A7%E6%89%BF/"/>
    
    <category term="多态" scheme="https://sweeneyzhou.top/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>包和导入</title>
    <link href="https://sweeneyzhou.top/%E5%8C%85%E5%92%8C%E5%AF%BC%E5%85%A5%E3%80%81%E9%9D%99%E6%80%81.html"/>
    <id>https://sweeneyzhou.top/%E5%8C%85%E5%92%8C%E5%AF%BC%E5%85%A5%E3%80%81%E9%9D%99%E6%80%81.html</id>
    <published>2021-04-21T01:01:41.808Z</published>
    <updated>2021-04-21T01:18:25.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一，包和导入"><a href="#一，包和导入" class="headerlink" title="一，包和导入"></a>一，包和导入</h3><h4 id="1-1-包"><a href="#1-1-包" class="headerlink" title="1.1 包"></a>1.1 包</h4><blockquote><p>包：关键字<code>package</code>，本质就是文件夹</p><p>问：为什么要创建不同的包？</p><p>答：因为一个项目中会有许多模块，一个模块中会涉及到很多相关的类，创建不同的包，将对应的类放在这些包中能提高对项目的管理。</p><p>任何一个类都必须在一个包中，并且这个类的第一行必须明确该类的完整路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qf.test;<span class="comment">// 当前类所属的包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><p>一个类的完整路径（全类名、类全名）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：Test1这个类的完整路径是com.qf.test.Test1</span><br></pre></td></tr></table></figure></blockquote><h4 id="1-2-包的命名"><a href="#1-2-包的命名" class="headerlink" title="1.2 包的命名"></a>1.2 包的命名</h4><blockquote><p>规则：标识符的规则</p><p>规范：全小写，用<code>.</code>来划分包的结构层次，一般使用域名倒置</p><p>常见的包名：</p><ol><li>测试包：test</li><li>工具包：util</li><li>实体包：domain、entity、pojo、bean</li><li>数据库：dao（data access object）</li><li>业务层：service、business</li><li>控制层：controller</li></ol></blockquote><h4 id="1-3-导入"><a href="#1-3-导入" class="headerlink" title="1.3 导入"></a>1.3 导入</h4><blockquote><p>导包：关键字<code>import</code>当一个类使用到了其他包中的类时，需要将这个类引入进来</p><p>注：</p><ol><li>同包中的类调用时无需导包</li><li>lang包中的类无需导入</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*import java.util.ArrayList;</span></span><br><span class="line"><span class="comment">import java.util.Arrays;</span></span><br><span class="line"><span class="comment">import java.util.Random;</span></span><br><span class="line"><span class="comment">import java.util.Scanner;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;<span class="comment">// 通配符，按需导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>注：不同包中有同名的类，需要使用时，可以通过以下方式区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        com.qf.test.Random r1 = <span class="keyword">new</span> com.qf.test.Random();</span><br><span class="line">        Random r2 = <span class="keyword">new</span> Random();</span><br><span class="line">        com.qf.entity.Random r3 = <span class="keyword">new</span>  com.qf.entity.Random();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="二，静态"><a href="#二，静态" class="headerlink" title="二，静态"></a>二，静态</h3><blockquote><p>关键字：<code>static</code></p></blockquote><h4 id="2-1-静态的特点"><a href="#2-1-静态的特点" class="headerlink" title="2.1 静态的特点"></a>2.1 静态的特点</h4><blockquote><ol><li><p>静态成员随着类的加载而加载是最先进入内存的</p></li><li><p>静态成员，不属于对象，属于整个类，是这个类的所有对象的共享内容</p></li><li><p>静态成员应该使用类名调用</p></li><li><p>静态的只能调用静态的，不能调用非静态的；非静态的既可以调用静态的也可以调用非静态的</p><p>注：后人知道前人，前人不知道后人</p></li><li><p>静态不能调用this</p></li><li><p>静态只能修饰成员</p></li></ol></blockquote><h4 id="2-2-静态常量"><a href="#2-2-静态常量" class="headerlink" title="2.2 静态常量"></a>2.2 静态常量</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 数据类型 变量名 = 值;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>一般静态常量都是<code>public</code>的</li><li>常量的命名规范：全大写，多个单词，用下划线连接</li><li>成员常量必须在创建时赋予初始值</li></ol></blockquote><h4 id="2-3-静态代码块"><a href="#2-3-静态代码块" class="headerlink" title="2.3 静态代码块"></a>2.3 静态代码块</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">// 静态代码块中的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>静态代码块最优先执行</li><li>静态代码块只执行一次</li></ol><p>作用：</p><ol><li>读取配置文件</li><li>对静态属性进行初始化</li></ol><p>注：多个静态代码块会根据书写顺序从上到下依次执行</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一，包和导入&quot;&gt;&lt;a href=&quot;#一，包和导入&quot; class=&quot;headerlink&quot; title=&quot;一，包和导入&quot;&gt;&lt;/a&gt;一，包和导入&lt;/h3&gt;&lt;h4 id=&quot;1-1-包&quot;&gt;&lt;a href=&quot;#1-1-包&quot; class=&quot;headerlink&quot; title=&quot;1.1 包&quot;&gt;&lt;/a&gt;1.1 包&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;包：关键字&lt;code&gt;package&lt;/code&gt;，本质就是文件夹&lt;/p&gt;
&lt;p&gt;问：为什么要创建不同的包？&lt;/p&gt;
&lt;p&gt;答：因为一个项目中会有许多模块，一个模块中会涉及到很多相关的类，创建不同的包，将对应的类放在这些包中能提高对项目的管理。&lt;/p&gt;
&lt;p&gt;任何一个类都必须在一个包中，并且这个类的第一行必须明确该类的完整路径&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; com.qf.test;&lt;span class=&quot;comment&quot;&gt;// 当前类所属的包&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test1&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;一个类的完整路径（全类名、类全名）&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;例如：Test1这个类的完整路径是com.qf.test.Test1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-2-包的命名&quot;&gt;&lt;a href=&quot;#1-2-包的命名&quot; class=&quot;headerlink&quot; title=&quot;1.2 包的命名&quot;&gt;&lt;/a&gt;1.2 包的命名&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;规则：标识符的规则&lt;/p&gt;
&lt;p&gt;规范：全小写，用&lt;code&gt;.&lt;/code&gt;来划分包的结构层次，一般使用域名倒置&lt;/p&gt;
&lt;p&gt;常见的包名：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;测试包：test&lt;/li&gt;
&lt;li&gt;工具包：util&lt;/li&gt;
&lt;li&gt;实体包：domain、entity、pojo、bean&lt;/li&gt;
&lt;li&gt;数据库：dao（data access object）&lt;/li&gt;
&lt;li&gt;业务层：service、business&lt;/li&gt;
&lt;li&gt;控制层：controller&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="后端编程" scheme="https://sweeneyzhou.top/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JAVA" scheme="https://sweeneyzhou.top/tags/JAVA/"/>
    
    <category term="学习笔记" scheme="https://sweeneyzhou.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础" scheme="https://sweeneyzhou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="包" scheme="https://sweeneyzhou.top/tags/%E5%8C%85/"/>
    
    <category term="导入" scheme="https://sweeneyzhou.top/tags/%E5%AF%BC%E5%85%A5/"/>
    
    <category term="静态" scheme="https://sweeneyzhou.top/tags/%E9%9D%99%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://sweeneyzhou.top/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"/>
    <id>https://sweeneyzhou.top/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html</id>
    <published>2021-04-21T01:01:41.787Z</published>
    <updated>2021-04-21T01:18:34.984Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一，成员和局部"><a href="#一，成员和局部" class="headerlink" title="一，成员和局部"></a>一，成员和局部</h3><blockquote><p>成员：也叫全局，定义在类中方法外</p><ol><li>成员变量</li><li>成员方法</li></ol><p>局部：定义在方法中</p><ol><li>局部变量</li></ol></blockquote><blockquote><p>局部变量和成员变量的区别：</p><ol><li><p>定义位置：局部变量定义在方法中，成员变量定义在方法外</p></li><li><p>作用范围：局部变量只能在定义它的方法中使用，成员变量可以在整个类中使用</p><p>重名问题：当局部变量和成员变量名相同时，采用<code>就近原则</code>进行调用</p></li><li><p>默认值：局部变量没有默认值，必须先赋值才可以使用，成员变量有默认值</p><p>成员变量的默认值与数组默认值的规则相同</p></li><li><p>在内存中的位置：成员变量在堆中，因为成员变量属于类的对象；局部变量在栈中，因为局部变量只能在定义它的方法中使用，方法被调用后进入栈内存</p></li><li><p>生命周期：局部变量从方法调用开始，到方法运行完毕后释放；成员变量从创建对象开始，到对象从堆内存中释放结束。</p></li></ol></blockquote><h3 id="二，面向对象的概念"><a href="#二，面向对象的概念" class="headerlink" title="二，面向对象的概念"></a>二，面向对象的概念</h3><blockquote><p>面向过程的语言：C语言</p><p>面向对象的语言：C++、Java、Python</p><p>面向过程和面向对象都是编程思想</p><p>区别：</p><ol><li>面向过程：重点放在程序的功能是如何执行的</li><li>面向对象：重点放在程序的功能可以找谁来完成</li></ol></blockquote><h3 id="三，类和对象"><a href="#三，类和对象" class="headerlink" title="三，类和对象"></a>三，类和对象</h3><blockquote><p>类：数据类型，一类事物的集合</p><ol><li>基本信息</li><li>行为</li></ol><p>对象：根据类创建出来的一个实体（实例），这个对象具有该类中所有的基本信息和行为</p><p>根据类创建出来的实体，称为创建对象、也称为实例化</p><p>例如：</p><p>类：</p><p>​    宠物类</p><ol><li>基本信息：昵称、种类、年龄、性别、价格</li><li>行为：吃、睡</li></ol><p>对象：</p><p>​    宠物对象</p><ol><li>基本信息：毛毛、田园犬、2、母、3000</li><li>行为：具体怎么吃、怎么睡</li></ol><p>代码中：基本信息=&gt;属性、行为=&gt;方法</p></blockquote><h3 id="四，类的定义和对象的创建"><a href="#四，类的定义和对象的创建" class="headerlink" title="四，类的定义和对象的创建"></a>四，类的定义和对象的创建</h3><h4 id="4-1-类的定义"><a href="#4-1-类的定义" class="headerlink" title="4.1 类的定义"></a>4.1 类的定义</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    属性</span><br><span class="line">    方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个Hero类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">// 血量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 攻击</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回城</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">back</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;回城&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-2-对象的创建"><a href="#4-2-对象的创建" class="headerlink" title="4.2 对象的创建"></a>4.2 对象的创建</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 对象名(引用变量) = <span class="keyword">new</span> 数据类型();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hero h1 = <span class="keyword">new</span> Hero();</span><br></pre></td></tr></table></figure></blockquote><h3 id="五，属性和方法的调用"><a href="#五，属性和方法的调用" class="headerlink" title="五，属性和方法的调用"></a>五，属性和方法的调用</h3><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法的调用：对象名.方法名(参数);</span><br><span class="line">属性的调用：</span><br><span class="line">    <span class="number">1.</span>获取：对象名.属性;</span><br><span class="line">    <span class="number">2.</span>赋值：对象名.属性 = 值;</span><br></pre></td></tr></table></figure></blockquote><h3 id="六，构造函数"><a href="#六，构造函数" class="headerlink" title="六，构造函数"></a>六，构造函数</h3><h4 id="6-1-构造函数的特点"><a href="#6-1-构造函数的特点" class="headerlink" title="6.1 构造函数的特点"></a>6.1 构造函数的特点</h4><blockquote><ol><li>构造方法的方法名与类名完全一致</li><li>每一个类都有一个默认的隐式的无参的构造函数</li><li>构造函数没有返回类型，连void都不能有</li><li>每次创建对象都会执行构造函数</li><li>一旦构造函数写出了，原来的默认构造函数就不存在了，除非重新写出它</li></ol></blockquote><h4 id="6-2-构造函数的作用"><a href="#6-2-构造函数的作用" class="headerlink" title="6.2 构造函数的作用"></a>6.2 构造函数的作用</h4><blockquote><ol><li>创建对象</li><li>创建对象的同时对属性进行初始化</li></ol></blockquote><h4 id="6-3-构造函数的重载"><a href="#6-3-构造函数的重载" class="headerlink" title="6.3 构造函数的重载"></a>6.3 构造函数的重载</h4><blockquote><p>概念：同一个类中构造函数的参数列表不同就是构造函数重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name, String nation, <span class="keyword">int</span> blood)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.nation = nation;</span><br><span class="line">    <span class="keyword">this</span>.blood = blood;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一，成员和局部&quot;&gt;&lt;a href=&quot;#一，成员和局部&quot; class=&quot;headerlink&quot; title=&quot;一，成员和局部&quot;&gt;&lt;/a&gt;一，成员和局部&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;成员：也叫全局，定义在类中方法外&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;成员变量&lt;/li&gt;
&lt;li&gt;成员方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;局部：定义在方法中&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;局部变量&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;局部变量和成员变量的区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义位置：局部变量定义在方法中，成员变量定义在方法外&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;作用范围：局部变量只能在定义它的方法中使用，成员变量可以在整个类中使用&lt;/p&gt;
&lt;p&gt;重名问题：当局部变量和成员变量名相同时，采用&lt;code&gt;就近原则&lt;/code&gt;进行调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;默认值：局部变量没有默认值，必须先赋值才可以使用，成员变量有默认值&lt;/p&gt;
&lt;p&gt;成员变量的默认值与数组默认值的规则相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在内存中的位置：成员变量在堆中，因为成员变量属于类的对象；局部变量在栈中，因为局部变量只能在定义它的方法中使用，方法被调用后进入栈内存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生命周期：局部变量从方法调用开始，到方法运行完毕后释放；成员变量从创建对象开始，到对象从堆内存中释放结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二，面向对象的概念&quot;&gt;&lt;a href=&quot;#二，面向对象的概念&quot; class=&quot;headerlink&quot; title=&quot;二，面向对象的概念&quot;&gt;&lt;/a&gt;二，面向对象的概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;面向过程的语言：C语言&lt;/p&gt;
&lt;p&gt;面向对象的语言：C++、Java、Python&lt;/p&gt;
&lt;p&gt;面向过程和面向对象都是编程思想&lt;/p&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;面向过程：重点放在程序的功能是如何执行的&lt;/li&gt;
&lt;li&gt;面向对象：重点放在程序的功能可以找谁来完成&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="后端编程" scheme="https://sweeneyzhou.top/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JAVA" scheme="https://sweeneyzhou.top/tags/JAVA/"/>
    
    <category term="学习笔记" scheme="https://sweeneyzhou.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础" scheme="https://sweeneyzhou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="成员变量" scheme="https://sweeneyzhou.top/tags/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"/>
    
    <category term="局部变量" scheme="https://sweeneyzhou.top/tags/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    
    <category term="面向对象" scheme="https://sweeneyzhou.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>方法</title>
    <link href="https://sweeneyzhou.top/%E6%96%B9%E6%B3%95.html"/>
    <id>https://sweeneyzhou.top/%E6%96%B9%E6%B3%95.html</id>
    <published>2021-04-21T01:01:41.786Z</published>
    <updated>2021-04-21T01:18:45.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一，方法的概念"><a href="#一，方法的概念" class="headerlink" title="一，方法的概念"></a>一，方法的概念</h3><blockquote><p>概念：方法就是一个包含了功能所需要的执行语句的代码块</p><p>好处：</p><ol><li>提高了代码的复用性</li><li>隐藏了功能的实现细节</li></ol></blockquote><h3 id="二，方法的组成"><a href="#二，方法的组成" class="headerlink" title="二，方法的组成"></a>二，方法的组成</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>            <span class="keyword">static</span>           <span class="keyword">void</span>          <span class="title">main</span>         <span class="params">(String[] args)</span>     </span>&#123;&#125; </span><br><span class="line">范围（权限）修饰符   其他的修饰符       返回类型        方法名          参数列表           方法体</span><br></pre></td></tr></table></figure><ol><li>范围（权限）修饰符：限定了方法的使用范围</li><li>其他的修饰符：static 静态的、final 最终的、abstract 抽象的、native 本地的、synchronized 同步的</li><li>返回类型：表示方法运行完毕后返回结果的数据类型</li><li>方法名</li><li>参数列表：表示方法在执行过程中需要的数据</li><li>方法体：方法中具体功能的实现</li></ol></blockquote><h3 id="三，方法的调用"><a href="#三，方法的调用" class="headerlink" title="三，方法的调用"></a>三，方法的调用</h3><blockquote><ol><li><p>调用本类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法名(参数);</span><br></pre></td></tr></table></figure></li><li><p>调用其他类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果该方法被static修饰</span></span><br><span class="line">该方法所在类的类名.方法名(参数);</span><br><span class="line"><span class="comment">// 如果该方法没有被static修饰</span></span><br><span class="line">数据类型 对象名 = <span class="keyword">new</span> 数据类型();</span><br><span class="line">对象名.方法名(参数);</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>注：</p><ol><li>方法被调用后会进入栈内存；方法运行完毕后会从栈内存中释放；栈内存的特点：<code>先进后出</code></li><li>方法的定义位置是在类中，其他方法之外的任意位置</li><li>方法只有在调用后才会执行</li></ol></blockquote><h3 id="四，方法的参数"><a href="#四，方法的参数" class="headerlink" title="四，方法的参数"></a>四，方法的参数</h3><h4 id="4-1-形式参数"><a href="#4-1-形式参数" class="headerlink" title="4.1 形式参数"></a>4.1 形式参数</h4><blockquote><p>定义方法时的参数列表叫形式参数，也叫形参</p><p>作用：限定了调用时，必须根据形参的个数、类型、顺序来传入参数</p></blockquote><h4 id="4-2-实际参数"><a href="#4-2-实际参数" class="headerlink" title="4.2 实际参数"></a>4.2 实际参数</h4><blockquote><p>调用方法时的参数列表叫实际参数，也叫实参</p><p>实参是真正参与运算的数据，实参会必须根据形参的个数、类型、顺序来传递给形参</p><p>注：</p><ol><li>实参传递给形参时存在自动类型转换</li><li>实参可以是常量、变量、表达式、还可以是其他方法返回值</li></ol></blockquote><h3 id="五，方法的返回类型"><a href="#五，方法的返回类型" class="headerlink" title="五，方法的返回类型"></a>五，方法的返回类型</h3><blockquote><p>返回指的是方法在运行完毕后，会将运行的结果返回给调用者</p><ol><li><p>返回类型是 void</p><p>表示这个方法没有返回值，这个方法在运行完毕后，不会将任何结果返回给调用者；</p><p>返回类型是void的方法可以使用<code>return</code>关键字来结束方法，此时<code>return</code>的功能仅仅是结束方法而不能返回结果。</p></li><li><p>返回类型不是 void</p><p>表示这个方法有返回值，返回的结果就是指定数据类型的值，这个方法在运行完毕后，会将结果返回给调用者；</p><p>此时这个方法必须有<code>return</code>，并且<code>return</code>后必须跟上返回的结果，返回结果的类型与返回类型必须一致</p><p>注：</p><ol><li>一个方法的返回类型是什么可以看成这个方法就是这个类型的值</li><li>返回结果与返回类型存在自动类型转换</li></ol></li></ol></blockquote><blockquote><p>return关键字：</p><ol><li>返回类型是void的方法，可以有return，也可以没有return，如果有return，return后一定不能有值，程序运行到return时会立即结束方法</li><li>返回类型不是void的方法，必须有return，以及返回的结果</li></ol></blockquote><h3 id="六，参数和返回类型是引用数据类型"><a href="#六，参数和返回类型是引用数据类型" class="headerlink" title="六，参数和返回类型是引用数据类型"></a>六，参数和返回类型是引用数据类型</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">    f1(i);</span><br><span class="line">    System.out.println(i);<span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    System.out.println(i);<span class="comment">// 3</span></span><br><span class="line">    i = <span class="number">4</span>;</span><br><span class="line">    System.out.println(i);<span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(arr);<span class="comment">// arr的地址</span></span><br><span class="line">    f2(arr);<span class="comment">// 传递了地址</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);<span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">    System.out.println(b);<span class="comment">// 接收了实参传递过来的地址，当前形参b的地址与实参arr的地址是同一个</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">4</span>;<span class="comment">// 对b数组中的元素进行了赋值，由于arr的地址与b的地址是同一个，所以也修改arr数组中的元素值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>参数和返回类型是引用数据类型时，传递的都是地址</p></blockquote><h3 id="七，可变参数"><a href="#七，可变参数" class="headerlink" title="七，可变参数"></a>七，可变参数</h3><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 方法名(数据类型...变量名)&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当传入实参时，可以传入任意多个指定类型的参数</p><p>特点：</p><ol><li>可变参数的本质是数组</li><li>可变参数只能出现在参数列表的末尾</li></ol></blockquote><blockquote><p>注：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(String...a)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用该方法时，可以传入一个String类型的数组，或者任意个String类型的值</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(String[]a)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用该方法时，只能传入一个String类型的数组</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="八，方法的重载"><a href="#八，方法的重载" class="headerlink" title="八，方法的重载"></a>八，方法的重载</h3><blockquote><p>概念：在同一个类中，多个方法具有相同的方法名，但参数列表不同就是方法的重载</p><p><code>方法名相同，参数列表不同</code></p><p>参数列表：个数不同、类型不同、顺序不同</p><p>好处：简化了方法名的定义，便于调用和记忆</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一，方法的概念&quot;&gt;&lt;a href=&quot;#一，方法的概念&quot; class=&quot;headerlink&quot; title=&quot;一，方法的概念&quot;&gt;&lt;/a&gt;一，方法的概念&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;概念：方法就是一个包含了功能所需要的执行语句的代码块&lt;/p&gt;
&lt;p&gt;好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提高了代码的复用性&lt;/li&gt;
&lt;li&gt;隐藏了功能的实现细节&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二，方法的组成&quot;&gt;&lt;a href=&quot;#二，方法的组成&quot; class=&quot;headerlink&quot; title=&quot;二，方法的组成&quot;&gt;&lt;/a&gt;二，方法的组成&lt;/h3&gt;&lt;blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;            &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt;           &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;          &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;         &lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;     &lt;/span&gt;&amp;#123;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;范围（权限）修饰符   其他的修饰符       返回类型        方法名          参数列表           方法体&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;范围（权限）修饰符：限定了方法的使用范围&lt;/li&gt;
&lt;li&gt;其他的修饰符：static 静态的、final 最终的、abstract 抽象的、native 本地的、synchronized 同步的&lt;/li&gt;
&lt;li&gt;返回类型：表示方法运行完毕后返回结果的数据类型&lt;/li&gt;
&lt;li&gt;方法名&lt;/li&gt;
&lt;li&gt;参数列表：表示方法在执行过程中需要的数据&lt;/li&gt;
&lt;li&gt;方法体：方法中具体功能的实现&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三，方法的调用&quot;&gt;&lt;a href=&quot;#三，方法的调用&quot; class=&quot;headerlink&quot; title=&quot;三，方法的调用&quot;&gt;&lt;/a&gt;三，方法的调用&lt;/h3&gt;</summary>
    
    
    
    <category term="后端编程" scheme="https://sweeneyzhou.top/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JAVA" scheme="https://sweeneyzhou.top/tags/JAVA/"/>
    
    <category term="学习笔记" scheme="https://sweeneyzhou.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础" scheme="https://sweeneyzhou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="方法" scheme="https://sweeneyzhou.top/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://sweeneyzhou.top/%E6%95%B0%E7%BB%84.html"/>
    <id>https://sweeneyzhou.top/%E6%95%B0%E7%BB%84.html</id>
    <published>2021-04-21T01:01:41.784Z</published>
    <updated>2021-04-21T01:06:04.674Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一，概念和特点"><a href="#一，概念和特点" class="headerlink" title="一，概念和特点"></a>一，概念和特点</h3><blockquote><p>概念：用于存储数据的容器</p><p>特点：</p><ol><li>只能存储同一种数据类型的值（定义时明确了数组的数据类型后，该数组就只能存储这个类型的数据）</li><li>数组的长度是固定的</li></ol></blockquote><h3 id="二，定义和创建"><a href="#二，定义和创建" class="headerlink" title="二，定义和创建"></a>二，定义和创建</h3><blockquote><p>格式：</p><ol><li><p>```java<br>数据类型[] 数组名 = new 数据类型[长度];</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2</span>. ```java</span><br><span class="line">   数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3</span>,...&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>```java<br>数据类型[] 数组名 = {值1,值2,值3,…};</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 三，元素的获取和赋值</span><br><span class="line"></span><br><span class="line">下标</span><br><span class="line"></span><br><span class="line">下标也称为索引，本质上就是元素在数组中的位置，一般使用<span class="keyword">index</span></span><br><span class="line"></span><br><span class="line">特点：下标的范围是<span class="symbol">`[0，长度-1]`</span></span><br><span class="line"></span><br><span class="line">获取</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line"></span><br><span class="line"><span class="symbol">``</span><span class="symbol">`java</span></span><br><span class="line"><span class="symbol">数组名[下标]</span></span><br></pre></td></tr></table></figure></li></ol><p>注：</p><ol><li>如果获取数组中的元素时，下标超出了最大范围，会发生 <code>ArrayIndexOutOfBoundsException</code>数组下标越界异常</li><li>如果数组只定义了长度，没赋初始值，那么数组中的元素也会有默认值，默认值和数据类型相关<ol><li>浮点类型的默认值是0.0</li><li>整数类型的默认值是0</li><li>字符类型的默认值是空格</li><li>布尔类型的默认值false</li><li>引用数据类型的默认值都是null</li></ol></li></ol></blockquote><blockquote><p>赋值</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[下标] = 值;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>注意事项</p><ol><li><p>下标的范围是<code>[0，长度-1]</code></p></li><li><p>数组长度的获取方式：<code>数组名.length</code></p></li><li><p>直接打印数组名输出的是数组在内存中的地址，如果输出的是char类型的数组名，输出的是数组中的值</p></li><li><p>数组的工具类Arrays中提供了toString()方法用于将数组以字符串形式返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>[] dd = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>];</span><br><span class="line">dd[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dd[<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line">dd[<span class="number">2</span>] = -<span class="number">8</span>;</span><br><span class="line">System.out.println(dd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组以字符串的形式输出</span></span><br><span class="line">System.out.println(Arrays.toString(dd));<span class="comment">// 要将哪个数组以字符串返回就将这个数组的名称写在toString()的括号中</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="四，数组的遍历"><a href="#四，数组的遍历" class="headerlink" title="四，数组的遍历"></a>四，数组的遍历</h3><h4 id="4-1-普通循环"><a href="#4-1-普通循环" class="headerlink" title="4.1 普通循环"></a>4.1 普通循环</h4><blockquote></blockquote><h4 id="4-2-增强循环-foreach"><a href="#4-2-增强循环-foreach" class="headerlink" title="4.2 增强循环(foreach)"></a>4.2 增强循环(foreach)</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(数据类型 变量 : 容器)&#123;</span><br><span class="line">    <span class="comment">// 这个变量接收的就是循环过程中从容器中获取到的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>foreach只能遍历数组、集合</li><li>foreach中没有下标的概念</li><li>定义的遍历会在每次循环时，自动接收数组中所遍历到的元素</li><li>foreach一般用于<code>遍历</code>容器</li></ol></blockquote><h3 id="五，数组的复制"><a href="#五，数组的复制" class="headerlink" title="五，数组的复制"></a>五，数组的复制</h3><blockquote><p>方式一：</p><p>遍历原始数组中的每一个元素，将它们依次复制给新数组中</p><p>方式二：</p><p>使用<code>System</code>类中的<code>arrayCopy()</code>方法</p><p>方式三：</p><p>使用<code>Arrays</code>类中的<code>copyOf()</code>方法</p></blockquote><blockquote><p>数组的地址：</p><p>数组是引用数据类型，只要是一个引用数据类型，在创建时就会在堆内存中开辟存储空间，每一个存储空间都有自己的地址。直接打印数组名输出的就是地址值。</p><p>当数组的变量被重新赋值后，这个数组就指向了新的地址。</p></blockquote><h3 id="六，二维数组"><a href="#六，二维数组" class="headerlink" title="六，二维数组"></a>六，二维数组</h3><h4 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1 概念"></a>6.1 概念</h4><blockquote><p>概念：二维数组是数组的数组，二维数组中的每一个元素都是一个一维数组</p></blockquote><h4 id="6-2-定义和创建"><a href="#6-2-定义和创建" class="headerlink" title="6.2 定义和创建"></a>6.2 定义和创建</h4><blockquote><p>1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型[][] 数组名 = <span class="keyword">new</span> 数据类型[m][n];</span><br><span class="line"><span class="comment">// 表示这个二维数组中有m个一维数组，每一个一维数组中有n个元素</span></span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型[][] 数组名 = <span class="keyword">new</span> 数据类型[m][];</span><br><span class="line"><span class="comment">// 表示这个二维数组中有m个一维数组</span></span><br></pre></td></tr></table></figure><p>注：</p><ol><li>使用这种方式创建的二维数组中的每一个一维数组需要单独创建，否则会发生 <code>NullPointerException空指针异常</code></li><li>二维数组中的一维数组在创建时不能使用直接赋值的简化形式来创建</li></ol><p>3.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[][] 数组名 = &#123;&#123;值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3</span>,...&#125;,&#123;值<span class="number">1</span>,值<span class="number">2</span>,...&#125;,&#123;值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3</span>,值<span class="number">4</span>,...&#125;,...&#125;;</span><br></pre></td></tr></table></figure></blockquote><h4 id="6-3-二维数组的遍历"><a href="#6-3-二维数组的遍历" class="headerlink" title="6.3 二维数组的遍历"></a>6.3 二维数组的遍历</h4><blockquote><p>普通for循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= arr.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= arr[i].length - <span class="number">1</span>;j++)&#123;</span><br><span class="line">        System.out.print(arr[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增强for循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] a : arr)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t : a)&#123;</span><br><span class="line">        System.out.print(t+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一，概念和特点&quot;&gt;&lt;a href=&quot;#一，概念和特点&quot; class=&quot;headerlink&quot; title=&quot;一，概念和特点&quot;&gt;&lt;/a&gt;一，概念和特点&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;概念：用于存储数据的容器&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只能存储同一种数据类型的值（定义时明确了数组的数据类型后，该数组就只能存储这个类型的数据）&lt;/li&gt;
&lt;li&gt;数组的长度是固定的&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二，定义和创建&quot;&gt;&lt;a href=&quot;#二，定义和创建&quot; class=&quot;headerlink&quot; title=&quot;二，定义和创建&quot;&gt;&lt;/a&gt;二，定义和创建&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;```java&lt;br&gt;数据类型[] 数组名 = new 数据类型[长度];&lt;/p&gt;
&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;. ```java&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   数据类型[] 数组名 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; 数据类型[]&amp;#123;值&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,值&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,值&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,...&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;```java&lt;br&gt;数据类型[] 数组名 = {值1,值2,值3,…};&lt;/p&gt;
&lt;figure class=&quot;highlight n1ql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 三，元素的获取和赋值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;下标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;下标也称为索引，本质上就是元素在数组中的位置，一般使用&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;特点：下标的范围是&lt;span class=&quot;symbol&quot;&gt;`[0，长度-1]`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;获取&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;格式：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;``&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;`java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;数组名[下标]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果获取数组中的元素时，下标超出了最大范围，会发生 &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;数组下标越界异常&lt;/li&gt;
&lt;li&gt;如果数组只定义了长度，没赋初始值，那么数组中的元素也会有默认值，默认值和数据类型相关&lt;ol&gt;
&lt;li&gt;浮点类型的默认值是0.0&lt;/li&gt;
&lt;li&gt;整数类型的默认值是0&lt;/li&gt;
&lt;li&gt;字符类型的默认值是空格&lt;/li&gt;
&lt;li&gt;布尔类型的默认值false&lt;/li&gt;
&lt;li&gt;引用数据类型的默认值都是null&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;赋值&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;数组名[下标] = 值;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="后端编程" scheme="https://sweeneyzhou.top/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JAVA" scheme="https://sweeneyzhou.top/tags/JAVA/"/>
    
    <category term="学习笔记" scheme="https://sweeneyzhou.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础" scheme="https://sweeneyzhou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="数组" scheme="https://sweeneyzhou.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>流程控制</title>
    <link href="https://sweeneyzhou.top/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html"/>
    <id>https://sweeneyzhou.top/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html</id>
    <published>2021-04-21T01:01:41.771Z</published>
    <updated>2021-04-21T01:06:20.178Z</updated>
    
    <content type="html"><![CDATA[<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><blockquote><p>顺序结构</p><p>分支结构</p><p>选择结构</p><p>循环结构</p></blockquote><h3 id="一，分支结构"><a href="#一，分支结构" class="headerlink" title="一，分支结构"></a>一，分支结构</h3><blockquote><p>关键字：if、else</p></blockquote><h4 id="1-1-单-if-结构"><a href="#1-1-单-if-结构" class="headerlink" title="1.1 单 if 结构"></a>1.1 单 if 结构</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑：判断条件表达式的结果，结果为true，执行代码块中的语句；反之，不执行</p></blockquote><h4 id="1-2-标准的-if-else-结构"><a href="#1-2-标准的-if-else-结构" class="headerlink" title="1.2 标准的 if - else 结构"></a>1.2 标准的 if - else 结构</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑：判断条件表达式的结果，结果为true，执行if代码块中的语句1；反之，执行else代码块中的语句2</p></blockquote><h4 id="1-3-多条件的-if-else-结构"><a href="#1-3-多条件的-if-else-结构" class="headerlink" title="1.3 多条件的 if - else 结构"></a>1.3 多条件的 if - else 结构</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>)&#123;</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件<span class="number">2</span>)&#123;</span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件<span class="number">3</span>)&#123;</span><br><span class="line">    语句<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>逻辑：依次判断每一个条件表达式，一旦有一个条件表达式的结果为true时，执行对应的代码块，其他条件表达式不再判断</p></blockquote><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>)&#123;</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件<span class="number">2</span>)&#123;</span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件<span class="number">3</span>)&#123;</span><br><span class="line">    语句<span class="number">3</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    语句n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑：依次判断每一个条件表达式，一旦有一个条件表达式的结果为true时，执行对应的代码块，其他条件表达式不再判断；如果没有任何一个if条件为true，则执行最后的else中的语句n</p></blockquote><h4 id="1-4-if-else的嵌套"><a href="#1-4-if-else的嵌套" class="headerlink" title="1.4 if - else的嵌套"></a>1.4 if - else的嵌套</h4><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//  老年[65,]  中年[30,65) 青年 [18,30) 未成年[0,18)</span></span><br><span class="line">&gt;Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;请输入您的年龄：&quot;</span>);</span><br><span class="line">&gt;<span class="keyword">int</span> age = sc.nextInt();</span><br><span class="line">&gt;<span class="keyword">if</span>(age &gt;= <span class="number">0</span> &amp;&amp; age &lt;= <span class="number">150</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(age &gt;= <span class="number">65</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;老年&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(age &gt;= <span class="number">30</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;中年&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(age &gt;= <span class="number">18</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;青年&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;未成年&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&gt;&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;非法数据&quot;</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="1-5-注意事项"><a href="#1-5-注意事项" class="headerlink" title="1.5 注意事项"></a>1.5 注意事项</h4><blockquote><ol><li>else不能单独使用</li><li>在if-else的嵌套使用中，只有满足了外层的条件，才能进入内层</li><li>如果if或者else所对应的代码块中只有一条语句，那么大括号可以省略</li></ol></blockquote><h3 id="二，选择结构"><a href="#二，选择结构" class="headerlink" title="二，选择结构"></a>二，选择结构</h3><blockquote><p>关键字：switch、case、break、default</p></blockquote><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">3</span>:</span><br><span class="line">        语句<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句n;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑：将表达式的结果与case后的值进行比较，当某一个case后的值与表达式的结果相同时，执行该case后的语句；如果没有任何一个case后的值与表达式的结果相同，则执行defalut后的语句n</p></blockquote><blockquote><p>注：</p><ol><li>每一个case后的值必须是唯一的</li><li>表达式结果的类型只能是：byte、short、int、char、String</li><li>case后值的类型必须与表达式结果的类型一致</li><li>default不是必需的</li><li>case和default的位置顺序是任意的</li></ol></blockquote><blockquote><p>break 关键字：break在switch-case结构中用于跳出整个结构，如果删除了break，那么程序会继续向下执行，直到遇到下一个break或者switch-case结束。</p></blockquote><h3 id="三，循环结构"><a href="#三，循环结构" class="headerlink" title="三，循环结构"></a>三，循环结构</h3><blockquote><p>循环必须具备的4个要素</p><ol><li>条件</li><li>循环体</li><li>初始化值</li><li>步进表达式</li></ol></blockquote><h4 id="3-1-while-循环"><a href="#3-1-while-循环" class="headerlink" title="3.1 while 循环"></a>3.1 while 循环</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件)&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑：判断条件的结果，结果为true，执行循环体，继续判断条件，当条件为false时，结束循环</p></blockquote><h4 id="3-2-do-while-循环"><a href="#3-2-do-while-循环" class="headerlink" title="3.2 do-while 循环"></a>3.2 do-while 循环</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;<span class="keyword">while</span>(条件);</span><br></pre></td></tr></table></figure><p>逻辑：先执行一次循环体，再判断条件，如果为true，执行循环体，再次判断条件，直到条件的结果为false，结束循环。</p><p>特点：至少执行一次循环体</p></blockquote><h4 id="3-3-for-循环"><a href="#3-3-for-循环" class="headerlink" title="3.3 for 循环"></a>3.3 for 循环</h4><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化值①;条件②;步进表达式③)&#123;</span><br><span class="line">    循环体④</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行循环：1 2 4 3 2 4 3 2 …. 2</p></blockquote><h4 id="3-4-break-和-continue"><a href="#3-4-break-和-continue" class="headerlink" title="3.4 break 和 continue"></a>3.4 break 和 continue</h4><blockquote><p>break：在switch-case和循环中，都用于结束整个结构</p><p>continue：只能用在循环中，用于跳过当前这趟循环，继续后续的循环</p></blockquote><h4 id="3-5-死循环"><a href="#3-5-死循环" class="headerlink" title="3.5 死循环"></a>3.5 死循环</h4><blockquote><p>概念：在编程中，一个靠自身控制无法终止的程序称为死循环，也叫无限循环</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-6-循环嵌套"><a href="#3-6-循环嵌套" class="headerlink" title="3.6 循环嵌套"></a>3.6 循环嵌套</h4><blockquote><p>概念：一个循环嵌套另一个循环；一个循环是另一个循环的循环体</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;流程控制&quot;&gt;&lt;a href=&quot;#流程控制&quot; class=&quot;headerlink&quot; title=&quot;流程控制&quot;&gt;&lt;/a&gt;流程控制&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;顺序结构&lt;/p&gt;
&lt;p&gt;分支结构&lt;/p&gt;
&lt;p&gt;选择结构&lt;/p&gt;
&lt;p&gt;循环结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一，分支结构&quot;&gt;&lt;a href=&quot;#一，分支结构&quot; class=&quot;headerlink&quot; title=&quot;一，分支结构&quot;&gt;&lt;/a&gt;一，分支结构&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;关键字：if、else&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-1-单-if-结构&quot;&gt;&lt;a href=&quot;#1-1-单-if-结构&quot; class=&quot;headerlink&quot; title=&quot;1.1 单 if 结构&quot;&gt;&lt;/a&gt;1.1 单 if 结构&lt;/h4&gt;</summary>
    
    
    
    <category term="后端编程" scheme="https://sweeneyzhou.top/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JAVA" scheme="https://sweeneyzhou.top/tags/JAVA/"/>
    
    <category term="学习笔记" scheme="https://sweeneyzhou.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础" scheme="https://sweeneyzhou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java的概述和环境搭建</title>
    <link href="https://sweeneyzhou.top/Java%E6%A6%82%E8%BF%B0%E5%92%8C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"/>
    <id>https://sweeneyzhou.top/Java%E6%A6%82%E8%BF%B0%E5%92%8C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</id>
    <published>2021-04-20T18:22:36.961Z</published>
    <updated>2021-04-21T01:06:43.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一，Java的概述和环境搭建"><a href="#一，Java的概述和环境搭建" class="headerlink" title="一，Java的概述和环境搭建"></a>一，Java的概述和环境搭建</h3><h4 id="1-1-什么是程序"><a href="#1-1-什么是程序" class="headerlink" title="1.1 什么是程序"></a>1.1 什么是程序</h4><blockquote><p>程序：解决生活中实际问题的由一系列指令组成的集合，即是软件、APP</p><p>程序开发：制作软件</p></blockquote><h4 id="1-2-Java的历史与特点"><a href="#1-2-Java的历史与特点" class="headerlink" title="1.2 Java的历史与特点"></a>1.2 Java的历史与特点</h4><blockquote><p>1995年由SUN公司开发的面向对象的程序设计语言，创始人<code>高斯林</code>称作<code>Java之父</code></p><p>Java：JavaME、JavaSE、JavaEE</p><p>2004年发布JDK1.5，更名为Java5</p><p>2009年被Oracle收购</p><p>2014年Oracle发布Java8</p><p>特点：</p><ol><li>面向对象</li><li>跨平台性：跨操作系统、服务器</li><li>安全性</li><li>健壮性</li></ol></blockquote><h4 id="1-3-Java的运行机制"><a href="#1-3-Java的运行机制" class="headerlink" title="1.3 Java的运行机制"></a>1.3 Java的运行机制</h4><blockquote><p>先编译，后运行</p><p><code>.java文件（编译）-&gt;.class二进制字节码文件（运行）</code></p><p>JDK：Java Development Kit，Java开发工具</p><p>​    包含：JRE + 类库 + 工具包（编译器、调试工具）</p><p>JRE：Java Runtime Enviroment，Java运行环境</p><p>​    包含：JVM + 解释器</p><p>JVM：Java Vitrual Machine，Java虚拟机</p><p>​    使用软件在不同的操作系统中，模拟相同的Java运行环境，使Java程序得以运行</p></blockquote><h4 id="1-4-Java的环境搭建"><a href="#1-4-Java的环境搭建" class="headerlink" title="1.4 Java的环境搭建"></a>1.4 Java的环境搭建</h4><blockquote><p>JDK的下载：<a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a></p><p>卸载：控制面板直接卸载即可</p><p>安装：双击即可，不要安装在有中文的路径下，jdk和jre要保持在同一个目录下</p><p>环境变量的配置：</p><ol><li>右键“此电脑”，点击“属性”，点击“高级系统设置”，在“高级”标签下，选择“环境变量”</li><li>在“系统变量”中，点击“新建”，在“变量名”中输入<code>JAVA_HOME</code>，在“变量值”中输入<code>C:\Program Files\Java\jdk1.8.0_152</code></li><li>点击“系统变量”中“Path”，点击“编辑”，添加<code>%JAVA_HOME%\bin</code>和<code>%JAVA_HOME%\jre\bin</code></li></ol></blockquote><h4 id="1-5-第一个Java程序"><a href="#1-5-第一个Java程序" class="headerlink" title="1.5 第一个Java程序"></a>1.5 第一个Java程序</h4><h5 id="1-5-1-编写代码"><a href="#1-5-1-编写代码" class="headerlink" title="1.5.1 编写代码"></a>1.5.1 编写代码</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;五五开&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java文件的扩展名是<code>.java</code></p></blockquote><h5 id="1-5-2-编译代码"><a href="#1-5-2-编译代码" class="headerlink" title="1.5.2 编译代码"></a>1.5.2 编译代码</h5><blockquote><p>通过<code>javac</code>指令对Java文件进行编译，编译后会生成对应的<code>.class</code>二进制字节码文件</p><p>步骤：</p><ol><li><p>按下<code>win + r</code>，输入<code>cmd</code>，按下回车，打开命令提示符 </p></li><li><p>输入：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd java文件所在的位置</span><br></pre></td></tr></table></figure><p>切换cmd的执行指令的位置是在当前Java文件所在的位置</p></li><li><p>输入：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac 文件名.java</span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="1-5-3-运行程序"><a href="#1-5-3-运行程序" class="headerlink" title="1.5.3 运行程序"></a>1.5.3 运行程序</h5><blockquote><p>通过<code>java</code>指令对编译后的<code>.class</code>执行，从而运行程序</p><p>在上述的cmd中继续输入：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java 文件名</span><br></pre></td></tr></table></figure></blockquote><h5 id="1-5-4-注意事项"><a href="#1-5-4-注意事项" class="headerlink" title="1.5.4 注意事项"></a>1.5.4 注意事项</h5><blockquote><ol><li><p>同一个Java文件可以定义多个类，但是只能有一个类是<code>public</code>的，并且该文件的文件名必须与这个被<code>public</code>修饰的类的类名一致</p></li><li><p>任何一个类在被编译后都会生成一个唯一的<code>.class</code>文件</p></li><li><p>一个类中，只能有一个主方法，每个类都可以有自己的主方法</p></li><li><p>Java代码都是以<code>;</code>和<code>&#125;</code>结尾</p></li><li><p>Java中所有的括号必须成对出现</p></li><li><p>任何一个程序必须有一个主函数，主函数也叫主方法是程序的入口，主函数必须被定义成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>层级之间必须有良好的缩进</p></li></ol></blockquote><h4 id="1-6-Java的语言规范"><a href="#1-6-Java的语言规范" class="headerlink" title="1.6 Java的语言规范"></a>1.6 Java的语言规范</h4><h5 id="1-6-1-注释"><a href="#1-6-1-注释" class="headerlink" title="1.6.1 注释"></a>1.6.1 注释</h5><blockquote><p>注释：对代码进行解释说明的文本</p><p>单行注释：// 注释内容</p><p>多行注释：/* 注释内容 */</p><p>文档注释：/** 注释内容 */，有文档注释的代码，可以通过以下指令生成外部文档API</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc -d . HelloWorld.java</span><br></pre></td></tr></table></figure><p>注：注释不参与编译、运行</p></blockquote><h5 id="1-6-2-关键字"><a href="#1-6-2-关键字" class="headerlink" title="1.6.2 关键字"></a>1.6.2 关键字</h5><blockquote><p>概念：在Java中已经预先定义好的具有特殊含义的单词</p><p>例如：public、class、static、void</p><p>注：main不是关键字</p></blockquote><h5 id="1-6-3-标识符"><a href="#1-6-3-标识符" class="headerlink" title="1.6.3 标识符"></a>1.6.3 标识符</h5><blockquote><p>概念：类、方法、变量的名字都是标识符</p><p>规则：</p><ol><li>可以由数字、字母、下划线、美元符组成</li><li>数字不能开头</li><li>不能与关键字重名</li></ol><p>规范：</p><ol><li>变量和方法：首字母小写，多个单词组成时，从第二个单词起每个单词的首字母大写（小驼峰）</li><li>类和接口：每个单词的首字母大写（大驼峰）</li><li>常量：所有字母大写，多个单词组成时，单词之间用下划线连接</li></ol></blockquote><h3 id="二，Java的基础语法"><a href="#二，Java的基础语法" class="headerlink" title="二，Java的基础语法"></a>二，Java的基础语法</h3><h4 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h4><blockquote><p>概念：不能变化的数据</p><p>分类：</p><ol><li><p>整数常量：所有整数</p></li><li><p>小数常量：所有小数</p></li><li><p>字符串常量：所有字符串，</p><p>字符串：一串字符，若干个字符组成的有序序列，字符串必须使用一对双引号括起来</p></li><li><p>字符常量：任何一个字符</p><p>例如：’1’、’+’、’a’、’Z’、’是’，由一对单引号括起来的单个字符，不能有空字符</p></li></ol></blockquote><h4 id="2-2-数据类型"><a href="#2-2-数据类型" class="headerlink" title="2.2 数据类型"></a>2.2 数据类型</h4><blockquote><p>在Java中有严格的数据类型的划分（强类型的语言）</p><p>在Java任何一个值，都有所对应的类型</p><p>分类：</p><ol><li>基本数据类型</li><li>引用数据类型</li></ol></blockquote><h5 id="2-2-1-基本数据类型"><a href="#2-2-1-基本数据类型" class="headerlink" title="2.2.1 基本数据类型"></a>2.2.1 基本数据类型</h5><blockquote><ol><li><p>整数类型</p><ol><li>byte：字节型，1个字节，范围：<code>-2^7 ~ 2^7-1 也就是 -128 ~ 127</code></li><li>short：短整型，2个字节，范围：<code>-2^15 ~ 2^15-1 也就是-32768 ~ 32767</code></li><li>int：整型，默认整型，4个字节，范围：<code>-2^31 ~ 2^31-1</code></li><li>long：长整型，8个字节，范围：<code>-2^63 ~ 2^63-1</code></li></ol></li><li><p>小数类型（浮点类型）</p><ol><li><p>float：单精度浮点类型，4个字节，</p><p>负数范围：<code>-3.4E38 ~ -1.4E-45</code> 正数范围：<code>1.4E-45 ~ 3.4E38</code></p></li><li><p>double：双精度浮点类型，8个字节，默认小数</p><p>负数范围：<code>-1.7E308 ~ -4.9E-324</code> 正数范围：<code>4.9E-324 ~ 1.7E308</code></p></li></ol></li><li><p>字符类型</p><ol><li>char：2个字节，范围：<code>0 ~ 65535</code>，它遵循Unicode万国码，字符值必须使用一对单引号括起来，有且只能有一个字符</li></ol></li><li><p>布尔类型</p><ol><li>boolean：1个字节，取值范围：<code>true/false</code>，描述成”满足条件”/“不满足条件”</li></ol></li></ol></blockquote><h5 id="2-2-2-引用数据类型"><a href="#2-2-2-引用数据类型" class="headerlink" title="2.2.2 引用数据类型"></a>2.2.2 引用数据类型</h5><blockquote><ol><li><p>字符串：Java 程序中的所有字符串字面值（如 <code>&quot;abc&quot;</code> ）都是字符串值，字符串中允许没有字符，称为空字符串，简称空串</p><p>定义格式：同基本数据类型的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String 变量名<span class="number">1</span> = 值;</span><br><span class="line">String 变量名<span class="number">2</span>;</span><br><span class="line">变量名<span class="number">2</span> = 值;</span><br></pre></td></tr></table></figure></li><li><p>数组</p></li><li><p>对象</p></li></ol></blockquote><h5 id="2-2-3-转义字符"><a href="#2-2-3-转义字符" class="headerlink" title="2.2.3 转义字符"></a>2.2.3 转义字符</h5><blockquote><p>Java中可以通过对特定字符进行转义，来表示其他含义</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&#x27;&#x27;</span><span class="string">&#x27;);// 这句话编译失败，我们需要对中间的单引号进行转义</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>转义符号：<code>\</code></p><p>常见的转义：</p><ol><li><code>\n</code>：换行符</li><li><code>\t</code>：制表符（缩进）</li><li><code>\&#39;</code>：单引号</li><li><code>\&quot;</code>：双引号</li><li><code>\\</code>：反斜杠</li></ol></blockquote><h4 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h4><h5 id="2-3-1-变量的概念"><a href="#2-3-1-变量的概念" class="headerlink" title="2.3.1 变量的概念"></a>2.3.1 变量的概念</h5><blockquote><p>计算机内存中的一块存储空间，是存储数据的基本单元</p></blockquote><h5 id="2-3-2-变量的定义"><a href="#2-3-2-变量的定义" class="headerlink" title="2.3.2 变量的定义"></a>2.3.2 变量的定义</h5><blockquote><ol><li>先定义，后赋值</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名;</span><br><span class="line">变量名 = 值;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义的同时赋值</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = 值;</span><br></pre></td></tr></table></figure><ol start="3"><li>同时为多个同类型的变量定义和赋值</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名<span class="number">1</span>,变量名<span class="number">2</span> = 值,变量名<span class="number">3</span> = 值,变量名<span class="number">4</span>,...;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>注：</p><ol><li>在同一个代码块中变量名不能重复</li><li>变量必须先赋值才能使用</li><li>赋值的类型必须与变量的类型一致</li><li>赋的值必须在指定类型范围中</li><li>将小数赋值给float类型的变量时，需要加上<code>f</code>或者<code>F</code></li><li>一个超过int范围的整数必须加上<code>l</code>或者<code>L</code></li></ol></blockquote><h4 id="2-4-运算符"><a href="#2-4-运算符" class="headerlink" title="2.4 运算符"></a>2.4 运算符</h4><h5 id="2-4-1-算术运算符"><a href="#2-4-1-算术运算符" class="headerlink" title="2.4.1 算术运算符"></a>2.4.1 算术运算符</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+：求和运算，如果参与运算的数据中有字符串，那么“+”就是拼接，拼接后的结果仍然是字符串</span><br><span class="line">-：求差</span><br><span class="line">*：求乘积</span><br><span class="line">/：求商，整数之间的除法可能存在精度损失</span><br><span class="line">%：取模，求余数</span><br><span class="line">    注：</span><br><span class="line">    <span class="number">1.</span>a % b，如果a &lt; b，结果就是a</span><br><span class="line">    <span class="number">2.</span>a % b，如果a &gt; b，结果是[<span class="number">0</span>,b-<span class="number">1</span>]</span><br><span class="line">    <span class="number">3.</span>a % b结果是正负与a一致</span><br><span class="line">++（自增<span class="number">1</span>）、--（自减<span class="number">1</span>）：</span><br><span class="line">    自增和自减的前置和后置：将++、--运算符写在变量前称为前置；反之，称为后置</span><br><span class="line">    <span class="number">1.</span>在单独运算时，前置和后置没有区别</span><br><span class="line">    <span class="number">2.</span>在复合运算时，</span><br><span class="line">    （<span class="number">1</span>）前置：先执行自增（减），再执行其他操作</span><br><span class="line">    （<span class="number">2</span>）后置：先执行其他操作，再执行自增（减）</span><br></pre></td></tr></table></figure></blockquote><h5 id="2-4-2-赋值运算符"><a href="#2-4-2-赋值运算符" class="headerlink" title="2.4.2 赋值运算符"></a>2.4.2 赋值运算符</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=：赋值，将=右边表达式的结果运算完毕后，赋值给=左边的变量</span><br><span class="line">+=：a += b 等价于 a = a + b</span><br><span class="line">-=：a -= b 等价于 a = a - b</span><br><span class="line">*=：a *= b 等价于 a = a * b</span><br><span class="line">/=：a /= b 等价于 a = a / b</span><br><span class="line">%=：a %= b 等价于 a = a % b</span><br></pre></td></tr></table></figure></blockquote><h5 id="2-4-3-逻辑运算符"><a href="#2-4-3-逻辑运算符" class="headerlink" title="2.4.3 逻辑运算符"></a>2.4.3 逻辑运算符</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;：与，并且，表达式两边只要出现了<span class="keyword">false</span>，整个表达式的结果就是<span class="keyword">false</span></span><br><span class="line">|：或，或者，表达式两边只要出现了<span class="keyword">true</span>，整个表达式的结果就是<span class="keyword">true</span></span><br><span class="line">!：非，取反，<span class="keyword">true</span>的取反结果是<span class="keyword">false</span>，<span class="keyword">false</span>的取反结果是<span class="keyword">true</span></span><br><span class="line">^：异或，表达式两边相同结果是<span class="keyword">false</span>，两边不同结果是<span class="keyword">true</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;：表达式左边为<span class="keyword">false</span>，表达式右边不再运算，整个表达式的结果是<span class="keyword">false</span></span><br><span class="line">||：表达式左边为<span class="keyword">true</span>，表达式右边不再运算，整个表达式的结果是<span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>注：</p><ol><li>逻辑运算符参与运算的数据和运算的结果一定是布尔值</li><li>多个布尔值的逻辑运算仍然遵循上述特点</li></ol></blockquote><h5 id="2-4-4-关系运算符"><a href="#2-4-4-关系运算符" class="headerlink" title="2.4.4 关系运算符"></a>2.4.4 关系运算符</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;</span><br><span class="line">&lt;</span><br><span class="line">&gt;=</span><br><span class="line">&lt;=</span><br><span class="line">==：比较两个值是否相等</span><br><span class="line">!=：比较两个值是否不相等</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>关系运算符的结果是布尔值</li><li>表达式两边的数据类型必须是相同的，或者可以互相转换的</li></ol></blockquote><h5 id="2-4-5-三元运算符"><a href="#2-4-5-三元运算符" class="headerlink" title="2.4.5 三元运算符"></a>2.4.5 三元运算符</h5><blockquote><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表达式<span class="number">1</span> ? 表达式<span class="number">2</span> : 表达式<span class="number">3</span></span><br></pre></td></tr></table></figure><p>逻辑：运算表达式1，结果为true执行表达式2；反之，执行表达式3</p><p>注：</p><ol><li>表达式1运算的结果必须是一个布尔值</li><li>表达式2、表达式3必须执行一个，并且只会执行一个</li><li>表达式2、表达式3可以是值，也可以是表达式，不能是语句</li></ol></blockquote><h5 id="2-4-6-位运算"><a href="#2-4-6-位运算" class="headerlink" title="2.4.6 位运算"></a>2.4.6 位运算</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;：按位与</span><br><span class="line">|：按位或</span><br><span class="line">^：按位异或</span><br></pre></td></tr></table></figure><p>将十进制数转换成二进制，按位进行<code>与、或、异或</code>的运算，再将最后的结果转换成十进制数</p><p>转换成的二进制数中的<code>0视作false，1视作true</code>，进行逻辑运算，运算完毕后，再转换成0或1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">3</span> &amp; <span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="number">6</span> | <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="number">4</span> &amp; <span class="number">5</span> | <span class="number">6</span> ^ <span class="number">7</span>);<span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>左移：将十进制数转换成二进制数，向左移动指定的位数，移动后用0补全，最后转换成十进制数</p><p>公式：<code>a &lt;&lt; b 等价于 a乘以2的b次方</code></p></blockquote><h4 id="2-5-数据类型转换"><a href="#2-5-数据类型转换" class="headerlink" title="2.5 数据类型转换"></a>2.5 数据类型转换</h4><blockquote><p>问：两种不同类型的数据是否可以一起运算？</p><p>答：可以</p></blockquote><h5 id="2-5-1-自动类型转换"><a href="#2-5-1-自动类型转换" class="headerlink" title="2.5.1 自动类型转换"></a>2.5.1 自动类型转换</h5><blockquote><p>概念：范围小的数据与范围大的数据运算时，结果会自动转换成范围大的数据类型</p><p>自动类型转换的规则：</p><p><code>double &gt; float &gt; long &gt; int &gt; short &gt; byte</code></p><p>注：</p><ol><li></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">120</span>;<span class="comment">// 编译通过，原因是120是常量，程序在执行过程中，不会发生变化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">byte</span> c = i;<span class="comment">// 编译失败，原因是i是int类型的变量，程序在执行过程中，i可能发生变化从而超出byte的范围</span></span><br></pre></td></tr></table></figure><ol start="2"><li>数据类型所占的空间大小（字节）与所能表示的数据范围无关</li></ol></blockquote><h5 id="2-5-2-强制类型转换"><a href="#2-5-2-强制类型转换" class="headerlink" title="2.5.2 强制类型转换"></a>2.5.2 强制类型转换</h5><blockquote><p>概念：范围大的数据赋值给范围小的数据类型的变量</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">范围小的数据类型 变量名 = （范围小的数据类型）范围大的数据类型的数据;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li><p>强制类型转换可能出现精度损失、数据错误等问题，所以慎用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">20.886f</span>;</span><br><span class="line"><span class="keyword">long</span> l = (<span class="keyword">long</span>)f;</span><br><span class="line">System.out.println(l);<span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> bb = (<span class="keyword">byte</span>)<span class="number">128</span>;</span><br><span class="line">System.out.println(bb);<span class="comment">// -128</span></span><br></pre></td></tr></table></figure></li><li><p>byte和short之间运算的结果是int</p></li><li><p>如果表达式的运算结果超过了范围，需要对整个表达式的结果进行强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// int b3 = b1 + b2;</span></span><br><span class="line"><span class="keyword">short</span> b3 = (<span class="keyword">short</span>) (b1 + b2);</span><br></pre></td></tr></table></figure></li><li><p>++、–、+=、-=、… 自带强制类型转换</p></li></ol></blockquote><h5 id="2-5-3-char的类型转换"><a href="#2-5-3-char的类型转换" class="headerlink" title="2.5.3 char的类型转换"></a>2.5.3 char的类型转换</h5><blockquote><p>char类型的数据可以与十进制数遵循ASCII码表进行转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">‘<span class="number">0</span>’~‘<span class="number">9</span>’：<span class="number">48</span>~<span class="number">57</span></span><br><span class="line"><span class="string">&#x27;A&#x27;</span>~<span class="string">&#x27;Z&#x27;</span>：<span class="number">65</span>~<span class="number">90</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span>~<span class="string">&#x27;z&#x27;</span>：<span class="number">97</span>~<span class="number">122</span>    </span><br></pre></td></tr></table></figure></blockquote><h3 id="三，Random、Scanner"><a href="#三，Random、Scanner" class="headerlink" title="三，Random、Scanner"></a>三，Random、Scanner</h3><h4 id="3-1-Random"><a href="#3-1-Random" class="headerlink" title="3.1 Random"></a>3.1 Random</h4><blockquote><p>概念：Random是系统提供的一个专门用于获取伪随机数的一个类，在这个类中提供了一些获取随机数的方法</p><p>使用步骤：</p><ol><li><p>创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br></pre></td></tr></table></figure></li><li><p>调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = r.nextDouble();<span class="comment">// 随机产生一个[0.0,1.0)范围内的浮点数</span></span><br><span class="line"><span class="keyword">int</span> num1 = r.nextInt();<span class="comment">// 随机产生一个int范围内的数</span></span><br><span class="line"><span class="keyword">int</span> num2 = r.nextInt(n);<span class="comment">// [0,n)</span></span><br></pre></td></tr></table></figure></li></ol><p>注：随机指定范围数据的公式：<code>[a,b]： nextInt(b-a+1)+a</code></p></blockquote><h4 id="3-2-Scanner"><a href="#3-2-Scanner" class="headerlink" title="3.2 Scanner"></a>3.2 Scanner</h4><blockquote><p>概念：Scanner是系统提供的一个专门用于接收键盘输入的类</p><p>使用步骤：</p><ol><li><p>创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure></li><li><p>调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sc.nextInt();<span class="comment">// 接收键盘输入的整数值</span></span><br><span class="line">sc.nextDouble();<span class="comment">// 接收键盘输入的浮点数</span></span><br><span class="line">sc.next();<span class="comment">// 接收键盘输入的字符串</span></span><br><span class="line">sc.nextLine();<span class="comment">// 接收键盘输入的字符串</span></span><br></pre></td></tr></table></figure></li></ol><p>注：</p><ol><li>next()和nextLine()都用于接收字符串，但是next()不能接收空白字符串</li><li>必须保证所调用方法能接收输入的数据类型，否则会发生<code>InputMisMatchException输入不匹配异常</code></li></ol><p>补：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nextInt(<span class="keyword">int</span> radix)：radix表示进制，</span><br><span class="line">例如：参数是<span class="number">2</span>，也就是nextInt(<span class="number">2</span>)，表示键盘所输入的内容，系统会将其视为一个二进制数，转换成十进制数后返回</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一，Java的概述和环境搭建&quot;&gt;&lt;a href=&quot;#一，Java的概述和环境搭建&quot; class=&quot;headerlink&quot; title=&quot;一，Java的概述和环境搭建&quot;&gt;&lt;/a&gt;一，Java的概述和环境搭建&lt;/h3&gt;&lt;h4 id=&quot;1-1-什么是程序&quot;&gt;&lt;a href=&quot;#1-1-什么是程序&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是程序&quot;&gt;&lt;/a&gt;1.1 什么是程序&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;程序：解决生活中实际问题的由一系列指令组成的集合，即是软件、APP&lt;/p&gt;
&lt;p&gt;程序开发：制作软件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-2-Java的历史与特点&quot;&gt;&lt;a href=&quot;#1-2-Java的历史与特点&quot; class=&quot;headerlink&quot; title=&quot;1.2 Java的历史与特点&quot;&gt;&lt;/a&gt;1.2 Java的历史与特点&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;1995年由SUN公司开发的面向对象的程序设计语言，创始人&lt;code&gt;高斯林&lt;/code&gt;称作&lt;code&gt;Java之父&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Java：JavaME、JavaSE、JavaEE&lt;/p&gt;
&lt;p&gt;2004年发布JDK1.5，更名为Java5&lt;/p&gt;
&lt;p&gt;2009年被Oracle收购&lt;/p&gt;
&lt;p&gt;2014年Oracle发布Java8&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;面向对象&lt;/li&gt;
&lt;li&gt;跨平台性：跨操作系统、服务器&lt;/li&gt;
&lt;li&gt;安全性&lt;/li&gt;
&lt;li&gt;健壮性&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="后端编程" scheme="https://sweeneyzhou.top/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JAVA" scheme="https://sweeneyzhou.top/tags/JAVA/"/>
    
    <category term="学习笔记" scheme="https://sweeneyzhou.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础" scheme="https://sweeneyzhou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
